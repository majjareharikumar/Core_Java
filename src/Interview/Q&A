1)What is comparable and comparator. And differences ?
-----------------------------------------------------------------
comparable is an interface and it is present in java.long package.
It is used to define natural order of objects.It has compareTo(Object o) method to compare current object with specific object.
Sorting logic is written in class it self so we have only one way to sort.
It is providing single sorting sequence and it will affects the original class.
It is sorting the list by default Id.
ex:- // Sorting using Comparable (by ID)
        Collections.sort(list);
        System.out.println("Sorted by ID (Comparable): " + list);

comparator is an interface and it is present in java.util package.
It is used to define custom sorting logic for different ways of sorting.
It has compare(Object o1, Object o2) method to compare 2 objects.
Sorting logic is written out side the class so we have multiple comparators for flexibility.
It is providing multiple sorting sequence and it will not affect the original class.
It is sorting the list by custom queries like by name, by salary...
ex:-// Sorting using Comparator (by Name)
       Collections.sort(list, Comparator.comparing(s -> s.name));
       System.out.println("Sorted by Name (Comparator): " + list);

2)How to make class Immutable?
------------------------------------
Declare the class as final so it cannot be extended.
Make all fields private and final so we can prevent direct access and reassignment.
Don't provide setter method so fields cannot be changed after object creation.
Initialize all fields via constructor so we can ensure all values to set only once
For mutable objects like data , return copies in getters  so it will prevent external modifications.

ex:-
final class Student {
    private final int id;
    private final String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
    public int getId() { return id; }
    public String getName() { return name; }
}

3) How to connect DB from java application?
-----------------------------------------------
->Add JDBC Driver: Include the database driver (like MySQL, Oracle) in your project classpath.
->Load the Driver (Optional in Java 6+):
  Class.forName("com.mysql.cj.jdbc.Driver");
->Create a Connection: Use DriverManager.getConnection() with DB URL, username, and password.
->Create Statement / PreparedStatement: To execute SQL queries.
->Execute Query: Use executeQuery() for SELECT, executeUpdate() for INSERT/UPDATE/DELETE.
->Process Results: Read data from ResultSet (for SELECT queries).
->Close Resources: Close ResultSet, Statement, and Connection to avoid memory leaks.

Steps to connect DB in Spring Boot:
->Add database dependency (like MySQL) in pom.xml.
->Configure application.properties with URL, username, password, and driver.
->Create Entity class with @Entity and @Id.
->Create Repository interface by extending JpaRepository.
->Autowire repository in Service/Controller → Spring Boot handles DB connection automatically.

4)Why Spring Boot?
->Simplifies setup: Auto configures spring applications with minimal boilerplate and xml
->Standalone Applications:Can run as a self contained jar for embedded tomcat, no need for external server.
->Faster Development: Reduces manual configurations; easy integration with Spring modules (JPA, Security, MVC).
->Production Ready: Built-in features like metrics, health checks, logging, and monitoring.
->Microservices Friendly: Ideal for building microservices with REST, messaging, and cloud integration.
->Opinionated Defaults: Provides default settings and conventions, so developers focus on business logic.
->Community & Ecosystem: Large community, lots of starters, libraries, and support for modern development.

5)How to cover private methods in Java (JUnit testing)?
Private methods are not directly accessible from test classes. The best approach is to test private indirectly through
public methods which is calling private methods. This ensures behavior of the method testing , not the internal implementation.

If we want to test private methods directly them we can use reflection API to access private methods.

Public Method:-
---------------
🧩 Example: Testing Private Method Indirectly
class Calculator {

    // Private method - not directly accessible
    private int add(int a, int b) {
        return a + b;
    }

    // Public method - calls the private method
    public int calculateSum(int x, int y) {
        return add(x, y);  // private method is tested here indirectly
    }
}

✅ JUnit Test
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class CalculatorTest {

    @Test
    void testCalculateSum() {
        Calculator calc = new Calculator();
        int result = calc.calculateSum(5, 7);
        assertEquals(12, result); // indirectly tests 'add' method
    }
}

Reflection APi:-
---------------
public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        Calculator calc = new Calculator();

        // Get private method reference
        Method method = Calculator.class.getDeclaredMethod("multiply", int.class, int.class);

        // Make it accessible
        method.setAccessible(true);

        // Invoke the method
        int result = (int) method.invoke(calc, 5, 6);

        System.out.println("Result: " + result); // Output: 30
    }

🧩 Why testing private methods directly is discouraged:
->Private methods are internal implementation details, not part of the class’s public behavior.
->When you test private methods directly, your tests become tightly coupled to internal logic — even small code changes can break tests.
->It violates encapsulation, one of the main principles of OOP.
->Unit tests should focus on “what” the class does (output), not “how” it does it (internal steps).
->Testing through public methods ensures you’re verifying real behavior, not private mechanics.
->Frameworks like Spring, JUnit, and Mockito also follow this design — they never test private code directly.

6)What communication do you use in Microservices?
->Microservices communicate with each other using Inter-Service Communication.
->It can be Synchronous (real-time) or Asynchronous (event-based).
->For Synchronous communication, we use REST APIs over HTTP using tools like Feign Client, RestTemplate, or WebClient.
->For Asynchronous communication, we use Message Brokers like Kafka, RabbitMQ, or ActiveMQ.
->REST is preferred when services need an immediate response.
->Messaging (Kafka, RabbitMQ) is used when we want loose coupling, scalability, and reliability.
->In real projects, a mix of both is used — REST for direct calls, Kafka for event-driven communication.

7)What is Mock and Spy in Mockito?
->Mock and Spy are both used to create test doubles (fake objects) in unit testing.
->A Mock is a complete fake object — all methods are stubbed by default (return null, 0, or false unless specified).
->We use when(...).thenReturn(...) to define its behavior.
->A Spy, on the other hand, wraps a real object — it calls real methods unless you explicitly stub them.
->Mock is used when you want full control and don’t care about real logic.
->Spy is used when you want to test a partially real object (some real methods + some mocked).
  Example:
  MyService mockService = Mockito.mock(MyService.class); // all fake
  MyService spyService = Mockito.spy(new MyService());   // real + fake mix

8)What are External Configurations and Profiles in Spring Boot?
->External Configuration means keeping application settings outside the code (e.g., database URL, username, passwords).
->These values are defined in application.properties or application.yml, or even in environment variables, command-line args, or config servers.
->It helps to avoid hardcoding values and makes applications easier to move across environments (dev, test, prod).
->Profiles are used to define environment-specific configurations.
->For example: application-dev.properties, application-test.properties, application-prod.properties.
  You can activate a profile using:
  spring.profiles.active=dev
->Based on the active profile, Spring Boot loads the corresponding configuration file automatically.

9)How to Remove Tomcat Server from a Spring Boot Application
->Spring Boot includes Tomcat as its default embedded web server (via spring-boot-starter-web).
->To remove Tomcat, you must exclude it from the starter dependency.
Example in pom.xml:

  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
      <exclusions>
          <exclusion>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-tomcat</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
->Then, you can add another server (like Jetty or Undertow) if needed.
  For Jetty, just add:
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jetty</artifactId>
  </dependency>
->If you want no embedded server at all (non-web app), use:
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
  </dependency>
 ->Finally, make sure your application class does not start a web context.

 10)Is it mandatory to have an Entity class to fetch data?
->If you are using JPA or Hibernate, then yes, it’s mandatory to have an Entity class.
->JPA works on the concept of Object-Relational Mapping (ORM) — it maps Java objects (entities) to database tables.
->Without an entity, JPA won’t know which table or columns to map the data to.
->However, if you are using JDBC Template or native SQL queries, you can fetch data without an entity — results come as List<Map<String, Object>> or custom DTOs.
->So, Entity is mandatory for ORM-based access, but not required for plain SQL-based access.
->Example: JdbcTemplate.queryForList("SELECT * FROM employee") doesn’t need an entity.
->But with JpaRepository<Employee, Long>, you must have @Entity class Employee.

11)Which version of Spring Boot are you using and why?
->I’m currently using Spring Boot 3.x, which is the latest stable version.
->It’s built on Spring Framework 6 and fully supports Jakarta EE 9+ (package names moved from javax.* to jakarta.*).
->Spring Boot 3 improves performance, security, and compatibility with Java 17+ (LTS version).
->It also supports AOT (Ahead-of-Time) compilation and GraalVM native image for faster startup and low memory usage.
->Dependency management is simplified with better observability (Micrometer, Prometheus, Grafana) support.
->I prefer using it because it’s modern, lightweight, and production-ready.
->However, in older projects, we sometimes use Spring Boot 2.7.x for backward compatibility with Java 8 or legacy systems.

I use Spring Boot 3.x because it’s the latest, faster, and optimized for Java 17+, offering better performance and observability.

12)Why Stream API in Java 8?
->The Stream API was introduced in Java 8 to process collections of data efficiently.
->Before Java 8, we used loops to iterate and filter data, which made code long, complex, and error-prone.
->Stream API allows declarative programming — you focus on what to do, not how to do it.
->It provides powerful methods like filter(), map(), sorted(), collect(), and reduce() for data transformation.
->It supports parallel processing using parallelStream(), improving performance on multi-core systems.
->Streams make code cleaner, readable, and maintainable with less boilerplate.
    Example:
   list.stream().filter(x -> x > 10).collect(Collectors.toList());
   — replaces several lines of loop code.

13)what is anonymous inner class and functional interface . differences ?
🧩Anonymous Inner Class
An anonymous inner class is a class without a name that is declared and instantiated at the same time.
It’s mainly used to override a method or provide implementation for an interface/class instantly.
Example (before Java 8):
Runnable r = new Runnable() {
    public void run() {
        System.out.println("Running...");
    }
};
It’s verbose — requires boilerplate code even for one-line logic.

🧩 Functional Interface
A Functional Interface has exactly one abstract method, marked with @FunctionalInterface.
It allows Lambda Expressions (introduced in Java 8) to provide implementation in a clean and concise way.
Example:
Runnable r = () -> System.out.println("Running...");
It’s lightweight, easier to read, and supports functional programming style.

14)can we call it a functional interface with 1 abstract method , default and static method?
✅ Yes, a Functional Interface can have one abstract method and any number of default or static methods.
->What defines it as functional is that it has exactly one abstract method — that’s what Lambda expressions implement.
->Default and static methods are not abstract, so they don’t break the functional interface rule.
Example:
@FunctionalInterface
interface MyInterface {
    void show();                    // abstract
    default void display() {}       // allowed
    static void print() {}          // allowed
}

->This interface is still functional because it has only one abstract method (show).
->You can still use it with a Lambda expression like:
MyInterface obj = () -> System.out.println("Hello!");
->Adding more than one abstract method will cause a compile-time error if it’s annotated with @FunctionalInterface

🧩 If we add more than one abstract method to a Functional Interface?
Adding more than one abstract method breaks the Functional Interface rule — it causes a compile-time error
if @FunctionalInterface is used and prevents Lambda usage.
Example:
@FunctionalInterface
interface MyInterface {
    void show();
    void display(); // ❌ Error – Multiple abstract methods
}
->Error: “Invalid '@FunctionalInterface' annotation; MyInterface is not a functional interface.”
->Without the annotation, the code compiles, but it cannot be used with a Lambda Expression.
->So the @FunctionalInterface annotation acts as a safety check to enforce the rule.

15)What is Deep Copy in Java?
->A Deep Copy means creating a completely independent copy of an object — including all the objects it references.
->In deep copy, the original and copied objects don’t share the same reference for nested objects.
->So, changes made in one object don’t affect the other.
   Example:
   class Address implements Cloneable {
       String city;
       public Address(String city) { this.city = city; }
       public Object clone() throws CloneNotSupportedException { return super.clone(); }
   }

   class Employee implements Cloneable {
       String name;
       Address address;
       public Employee(String name, Address address) {
           this.name = name; this.address = address;
       }
       public Object clone() throws CloneNotSupportedException {
           Employee e = (Employee) super.clone();
           e.address = (Address) address.clone(); // deep copy
           return e;
       }
   }

   Employee e1 = new Employee("Hari", new Address("Bangalore"));
   Employee e2 = (Employee) e1.clone();
   e2.address.city = "Chennai";
   System.out.println(e1.address.city); // Output: Bangalore ✅ (not affected)
->In deep copy, both e1 and e2 have separate Address objects.

->In contrast, a shallow copy copies only the top-level object — both share the same nested reference.
->The original and copy share the same reference for inner objects.
->Change in one object affects the other.

16)JVM Architecture (Java Virtual Machine)
JVM (Java Virtual Machine) is the part of JRE responsible for executing Java bytecode.
It provides platform independence — “Write Once, Run Anywhere”.
The JVM architecture mainly consists of three components:
->Class Loader Subsystem
->Runtime Data Areas (Memory)
->Execution Engine

JVM loads bytecode using the Class Loader, stores data in Runtime Memory Areas,
and executes it using the Execution Engine with the help of the JIT Compiler and Garbage Collector.

17)Static keyword?

18)Can we use HashMap in Multi-threaded Environments?
No, a normal HashMap is not thread-safe and should not be used directly in a multi-threaded environment.
When multiple threads modify a HashMap at the same time (e.g., put() or resize()), it can lead to data inconsistency or even infinite loops.
To use maps safely across threads, Java provides thread-safe alternatives.
The main ones are:
ConcurrentHashMap → Preferred in multithreading (high performance + safe).
Collections.synchronizedMap(new HashMap<>()) → Synchronized but slower.

ConcurrentHashMap uses segment-level locking (or bucket-level in Java 8), allowing multiple threads to read/write concurrently.

Example:
Map<String, Integer> map = new ConcurrentHashMap<>();
map.put("Hari", 100);

Hence, HashMap is unsafe, but ConcurrentHashMap is the recommended choice for multi-threaded programs.

🧩 What is ConcurrentHashMap in Java?
ConcurrentHashMap is a thread-safe version of HashMap introduced in Java 1.5 (in java.util.concurrent package).
It allows multiple threads to read and write concurrently without corrupting the data.
Unlike Hashtable or Collections.synchronizedMap(), it doesn’t lock the entire map — it locks only a portion (bucket/segment).
This improves performance and reduces contention between threads.
In Java 8, it uses a fine-grained locking mechanism (using internal synchronized blocks and CAS — Compare-And-Swap).
null keys and values are not allowed to avoid confusion during concurrent updates.
Example:
Map<String, Integer> map = new ConcurrentHashMap<>();
map.put("Hari", 100);
map.put("Kumar", 200);

It’s ideal for multi-threaded caching, counters, or real-time data sharing.

19)Difference Between HashMap and Hashtable
Synchronization:
   HashMap is not synchronized → not thread-safe.
   Hashtable is synchronized → thread-safe, but slower in single-threaded use.
Null Values:
   HashMap allows one null key and multiple null values.
   Hashtable doesn’t allow any null key or value (throws NullPointerException).
Performance:
   HashMap is faster because it’s non-synchronized.
   Hashtable is slower due to synchronization on every method.
Introduced In:
   HashMap → Introduced in Java 1.2 (part of Collections Framework).
   Hashtable → Introduced in Java 1.0 (legacy class, before Collections Framework).
Iterator Type:
   HashMap uses fail-fast iterators (throws ConcurrentModificationException).
   Hashtable uses enumeration, which is not fail-fast.
Usage Recommendation:
   Prefer HashMap for single-threaded or controlled concurrency.
   Use ConcurrentHashMap instead of Hashtable for multithreading.

20) Internal working of HashMap?

21)Spring Boot Internal Annotations
The main class of a Spring Boot app is annotated with @SpringBootApplication, which is a meta-annotation that combines three important annotations:
   @SpringBootApplication =
       @Configuration + @EnableAutoConfiguration + @ComponentScan
@Configuration → Tells Spring that this class contains bean definitions using @Bean methods.
@EnableAutoConfiguration → Enables Spring Boot’s auto-configuration feature, which automatically configures beans based on dependencies in the classpath (e.g., DataSource, DispatcherServlet, etc.).
@ComponentScan → Scans the current package and sub-packages to find Spring components like @Component, @Service, @Repository, and @Controller.
Together, these annotations make Spring Boot apps ready-to-run with minimal configuration — you just write the logic and Boot wires everything automatically.
Additional internal annotations used are:
   @RestController → Combines @Controller + @ResponseBody.
   @SpringBootConfiguration → Specialized form of @Configuration.

22)@CrossOrigin in Spring Boot
@CrossOrigin is used to enable Cross-Origin Resource Sharing (CORS) in Spring Boot applications.
CORS is a browser security mechanism that restricts web pages from making requests to a different domain or port (for example, React app on localhost:3000 calling Spring Boot API on localhost:8080).
By default, browsers block such cross-origin requests for security reasons.
Using @CrossOrigin, we tell Spring Boot to allow requests from specific origins.
   @CrossOrigin(origins = "http://localhost:3000")
   @RestController
   public class EmployeeController { ... }
You can apply it at class level (for all APIs in the controller) or method level (for specific endpoints).
It supports extra attributes like methods, allowedHeaders, and maxAge to fine-tune CORS behavior.
If not configured, your frontend may get a CORS error like “Access to fetch at ... has been blocked by CORS policy.”

23)Difference between @Controller and @RestController
@Controller is used in Spring MVC to handle web requests and return views (like JSP, Thymeleaf pages).
@RestController is introduced in Spring Boot (Spring 4) to simplify building RESTful web services that return JSON or XML data.
@RestController is basically a shortcut for @Controller + @ResponseBody.
When you use @Controller, you need to manually add @ResponseBody on methods if you want to return data (not view).
When you use @RestController, every method by default returns the response body directly (e.g., JSON) — no view rendering.
  Example:
    @Controller
   public class MyController {
       @GetMapping("/home")
       public String home() { return "index"; } // returns view name
   }

   @RestController
   public class MyRestController {
       @GetMapping("/user")
       public User getUser() { return new User("Hari", 30); } // returns JSON
   }
So, use @Controller for web apps (UI) and @RestController for APIs (data exchange).

24)Stereotype Annotations in Spring
Stereotype annotations are specialized annotations in Spring used to define the roles of classes in the application context.
They tell Spring which classes should be automatically detected during component scanning and registered as Spring Beans.
The main stereotype annotations are:
   @Component → Generic annotation for any Spring-managed bean.
   @Service → Marks a class that holds business logic.
   @Repository → Marks a DAO layer or data access class; adds extra exception translation.
   @Controller → Used in web MVC layer to handle web requests.
All these annotations are specializations of @Component, meaning they behave like components but are used for better readability and layered architecture.
They help Spring perform component scanning automatically when @ComponentScan is used.

25)Segregation of Stereotype vs Non-Stereotype Annotations
Stereotype annotations are those that define the role of a class in the Spring application and allow automatic bean detection through component scanning.
Examples: @Component, @Service, @Repository, @Controller, and @RestController.
These annotations are applied at the class level and tell Spring to create and manage the object in its ApplicationContext.
Non-stereotype annotations do not create beans by themselves — instead, they add behavior, configuration, or metadata to existing beans.
Examples: @Autowired, @Value, @Qualifier, @Bean, @Configuration, @Primary, @Transactional.
   Stereotype → "What kind of bean this class is."
   Non-stereotype → "How this bean behaves or interacts."
In short:
   Stereotype = Bean definition (class-level)
   Non-stereotype = Bean behavior/configuration (method or field-level)

26)How to Configure a Database in Spring Boot
Spring Boot provides auto-configuration for databases — you just add the JDBC or JPA dependency and define connection details in application.
properties or application.yml.
   Example (application.properties):
   spring.datasource.url=jdbc:mysql://localhost:3306/employee_db
   spring.datasource.username=root
   spring.datasource.password=root123
   spring.jpa.hibernate.ddl-auto=update
   spring.jpa.show-sql=true

When the app starts, Spring Boot automatically creates a DataSource, connects to the DB, and configures JPA/Hibernate if dependencies are present.
You can also use @Entity classes and JpaRepository interfaces to perform CRUD operations without writing SQL.
Optionally, you can define profiles (like dev, test, prod) with different DB configs using application-dev.properties.
If you want to manually configure, you can use a @Configuration class and define a DataSource bean using @Bean.

27)Default Spring Boot Dependencies
When you create a Spring Boot project (using Spring Initializr), it automatically adds default dependencies through the spring-boot-starter modules.
The most common default dependency is:
   spring-boot-starter → includes core Spring, logging (Logback + SLF4J), and auto-configuration support.

Other frequently included starters (based on project type):
   spring-boot-starter-web → for REST APIs (includes Spring MVC, Jackson, Tomcat).
   spring-boot-starter-data-jpa → for database access (includes Hibernate + JPA).
   spring-boot-starter-test → for unit and integration testing (JUnit, Mockito).

These starters bundle multiple libraries, reducing the need to manage versions manually.
Spring Boot manages all compatible versions through Spring Boot Parent (spring-boot-dependencies) in the POM.
This ensures version consistency, faster setup, and no dependency conflicts.

28)Internal Methods of Stream API
The Stream API internally works using two types of operations:
   Intermediate Operations
   Terminal Operations
Intermediate methods → return a new Stream and are lazy, meaning they don’t execute until a terminal operation is called.
   Examples: filter(), map(), sorted(), distinct(), limit(), skip().
Terminal methods → trigger the processing of the stream and produce a result or side effect.
   Examples: collect(), forEach(), reduce(), count(), findFirst(), anyMatch().
Internally, the Stream API uses Spliterator and Pipeline concepts — data flows in a chain through these methods.
Each intermediate method adds a stage to the pipeline, and terminal operations trigger the execution of all stages together.
Stream API internally uses functional interfaces (like Predicate, Function, Consumer) to define its logic.

29)about DSA?

30)Difficulties Faced in My Project
One major challenge I faced was handling data consistency across multiple microservices while processing real-time transactions.
Since each service had its own database, maintaining atomicity and rollback in case of partial failures was tricky.
We solved it using Kafka for event-driven communication and Saga Pattern for managing distributed transactions.
Another challenge was debugging production issues — we used tools like Splunk, Grafana, and Dynatrace to trace logs and monitor performance.
I also faced connection timeout and slow query issues in DB2, which we fixed by optimizing queries and configuring connection pools.
During deployments, version mismatches between services caused failures — we overcame this using Git branching strategy and CI/CD validation.
These challenges taught me how to design fault-tolerant, scalable, and maintainable microservices.

31)How to Generate a Primary Key in Spring Boot (JPA)
In Spring Data JPA, we use the annotation @Id to mark a field as the primary key in the entity class.
To make it auto-generated, we add @GeneratedValue along with a generation strategy.
   Example:
   @Entity
   public class Employee {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String name;
   }
The strategy attribute defines how the primary key is generated:
   IDENTITY → Auto-increment (DB handles it).
   SEQUENCE → Uses a database sequence (common in Oracle, PostgreSQL).
   TABLE → Uses a separate table to store sequence values.
   AUTO → Lets JPA decide the best strategy based on the database.
You can also define a custom sequence using @SequenceGenerator if your DB supports it.
For non-relational DBs or manual control, you can assign IDs programmatically before saving.

32)What is JWT (JSON Web Token)?
JWT stands for JSON Web Token, which is a secure, compact way to transmit user information between two parties — usually client and server.
It is mainly used for authentication and authorization in modern applications (especially in REST APIs).
A JWT is a digitally signed token that confirms the user’s identity and allows access to protected resources without storing session data on the server.
A JWT consists of three parts:
   Header → contains the algorithm & token type.
   Payload → contains user details and claims (like username, roles).
   Signature → ensures data integrity (using a secret key or RSA key).
Flow: After successful login, the server generates a JWT → sends it to the client → client includes it in every request’s Authorization header.
Server validates the signature before allowing access — no need to query the DB each time.
JWT helps achieve stateless authentication in Spring Boot microservices.

33)Authentication vs Authorization
Authentication is the process of verifying the user’s identity — confirming who the user is (like username and password validation).
Authorization is the process of checking what actions or resources that user is allowed to access (like admin vs normal user).
   In simple terms:
   Authentication → “Who are you?”
   Authorization → “What can you do?”
Example: When you log into a banking app → login step = Authentication, viewing only your account and not others’ = Authorization.
In Spring Security, authentication is handled by AuthenticationManager and UserDetailsService.
Authorization is managed through roles and authorities, usually with annotations like @PreAuthorize("hasRole('ADMIN')") or @Secured.
Both processes often work together — you must be authenticated first before authorization can be applied.


