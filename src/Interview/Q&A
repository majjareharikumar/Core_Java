1)What is comparable and comparator. And differences ?
-----------------------------------------------------------------
comparable is an interface and it is present in java.long package.
It is used to define natural order of objects.It has compareTo(Object o) method to compare current object with specific object.
Sorting logic is written in class it self so we have only one way to sort.
It is providing single sorting sequence and it will affects the original class.
It is sorting the list by default Id.
ex:- // Sorting using Comparable (by ID)
        Collections.sort(list);
        System.out.println("Sorted by ID (Comparable): " + list);

comparator is an interface and it is present in java.util package.
It is used to define custom sorting logic for different ways of sorting.
It has compare(Object o1, Object o2) method to compare 2 objects.
Sorting logic is written out side the class so we have multiple comparators for flexibility.
It is providing multiple sorting sequence and it will not affect the original class.
It is sorting the list by custom queries like by name, by salary...
ex:-// Sorting using Comparator (by Name)
       Collections.sort(list, Comparator.comparing(s -> s.name));
       System.out.println("Sorted by Name (Comparator): " + list);

2)How to make class Immutable?
------------------------------------
Declare the class as final so it cannot be extended.
Make all fields private and final so we can prevent direct access and reassignment.
Don't provide setter method so fields cannot be changed after object creation.
Initialize all fields via constructor so we can ensure all values to set only once
For mutable objects like data , return copies in getters  so it will prevent external modifications.

ex:-
final class Student {
    private final int id;
    private final String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
    public int getId() { return id; }
    public String getName() { return name; }
}

3) How to connect DB from java application?
-----------------------------------------------
->Add JDBC Driver: Include the database driver (like MySQL, Oracle) in your project classpath.
->Load the Driver (Optional in Java 6+):
  Class.forName("com.mysql.cj.jdbc.Driver");
->Create a Connection: Use DriverManager.getConnection() with DB URL, username, and password.
->Create Statement / PreparedStatement: To execute SQL queries.
->Execute Query: Use executeQuery() for SELECT, executeUpdate() for INSERT/UPDATE/DELETE.
->Process Results: Read data from ResultSet (for SELECT queries).
->Close Resources: Close ResultSet, Statement, and Connection to avoid memory leaks.

Steps to connect DB in Spring Boot:
->Add database dependency (like MySQL) in pom.xml.
->Configure application.properties with URL, username, password, and driver.
->Create Entity class with @Entity and @Id.
->Create Repository interface by extending JpaRepository.
->Autowire repository in Service/Controller → Spring Boot handles DB connection automatically.

4)Why Spring Boot?
->Simplifies setup: Auto configures spring applications with minimal boilerplate and xml
->Standalone Applications:Can run as a self contained jar for embedded tomcat, no need for external server.
->Faster Development: Reduces manual configurations; easy integration with Spring modules (JPA, Security, MVC).
->Production Ready: Built-in features like metrics, health checks, logging, and monitoring.
->Microservices Friendly: Ideal for building microservices with REST, messaging, and cloud integration.
->Opinionated Defaults: Provides default settings and conventions, so developers focus on business logic.
->Community & Ecosystem: Large community, lots of starters, libraries, and support for modern development.

5)How to cover private methods in Java (JUnit testing)?
Private methods are not directly accessible from test classes. The best approach is to test private indirectly through
public methods which is calling private methods. This ensures behavior of the method testing , not the internal implementation.

If we want to test private methods directly them we can use reflection API to access private methods.

Public Method:-
---------------
🧩 Example: Testing Private Method Indirectly
class Calculator {

    // Private method - not directly accessible
    private int add(int a, int b) {
        return a + b;
    }

    // Public method - calls the private method
    public int calculateSum(int x, int y) {
        return add(x, y);  // private method is tested here indirectly
    }
}

✅ JUnit Test
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class CalculatorTest {

    @Test
    void testCalculateSum() {
        Calculator calc = new Calculator();
        int result = calc.calculateSum(5, 7);
        assertEquals(12, result); // indirectly tests 'add' method
    }
}

Reflection APi:-
---------------
public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        Calculator calc = new Calculator();

        // Get private method reference
        Method method = Calculator.class.getDeclaredMethod("multiply", int.class, int.class);

        // Make it accessible
        method.setAccessible(true);

        // Invoke the method
        int result = (int) method.invoke(calc, 5, 6);

        System.out.println("Result: " + result); // Output: 30
    }

🧩 Why testing private methods directly is discouraged:
->Private methods are internal implementation details, not part of the class’s public behavior.
->When you test private methods directly, your tests become tightly coupled to internal logic — even small code changes can break tests.
->It violates encapsulation, one of the main principles of OOP.
->Unit tests should focus on “what” the class does (output), not “how” it does it (internal steps).
->Testing through public methods ensures you’re verifying real behavior, not private mechanics.
->Frameworks like Spring, JUnit, and Mockito also follow this design — they never test private code directly.

6)What communication do you use in Microservices?
->Microservices communicate with each other using Inter-Service Communication.
->It can be Synchronous (real-time) or Asynchronous (event-based).
->For Synchronous communication, we use REST APIs over HTTP using tools like Feign Client, RestTemplate, or WebClient.
->For Asynchronous communication, we use Message Brokers like Kafka, RabbitMQ, or ActiveMQ.
->REST is preferred when services need an immediate response.
->Messaging (Kafka, RabbitMQ) is used when we want loose coupling, scalability, and reliability.
->In real projects, a mix of both is used — REST for direct calls, Kafka for event-driven communication.

7)What is Mock and Spy in Mockito?
->Mock and Spy are both used to create test doubles (fake objects) in unit testing.
->A Mock is a complete fake object — all methods are stubbed by default (return null, 0, or false unless specified).
->We use when(...).thenReturn(...) to define its behavior.
->A Spy, on the other hand, wraps a real object — it calls real methods unless you explicitly stub them.
->Mock is used when you want full control and don’t care about real logic.
->Spy is used when you want to test a partially real object (some real methods + some mocked).
  Example:
  MyService mockService = Mockito.mock(MyService.class); // all fake
  MyService spyService = Mockito.spy(new MyService());   // real + fake mix

8)What are External Configurations and Profiles in Spring Boot?
->External Configuration means keeping application settings outside the code (e.g., database URL, username, passwords).
->These values are defined in application.properties or application.yml, or even in environment variables, command-line args, or config servers.
->It helps to avoid hardcoding values and makes applications easier to move across environments (dev, test, prod).
->Profiles are used to define environment-specific configurations.
->For example: application-dev.properties, application-test.properties, application-prod.properties.
  You can activate a profile using:
  spring.profiles.active=dev
->Based on the active profile, Spring Boot loads the corresponding configuration file automatically.

9)How to Remove Tomcat Server from a Spring Boot Application
->Spring Boot includes Tomcat as its default embedded web server (via spring-boot-starter-web).
->To remove Tomcat, you must exclude it from the starter dependency.
Example in pom.xml:

  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
      <exclusions>
          <exclusion>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-tomcat</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
->Then, you can add another server (like Jetty or Undertow) if needed.
  For Jetty, just add:
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jetty</artifactId>
  </dependency>
->If you want no embedded server at all (non-web app), use:
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
  </dependency>
 ->Finally, make sure your application class does not start a web context.

 10)Is it mandatory to have an Entity class to fetch data?
->If you are using JPA or Hibernate, then yes, it’s mandatory to have an Entity class.
->JPA works on the concept of Object-Relational Mapping (ORM) — it maps Java objects (entities) to database tables.
->Without an entity, JPA won’t know which table or columns to map the data to.
->However, if you are using JDBC Template or native SQL queries, you can fetch data without an entity — results come as List<Map<String, Object>> or custom DTOs.
->So, Entity is mandatory for ORM-based access, but not required for plain SQL-based access.
->Example: JdbcTemplate.queryForList("SELECT * FROM employee") doesn’t need an entity.
->But with JpaRepository<Employee, Long>, you must have @Entity class Employee.

11)Which version of Spring Boot are you using and why?
->I’m currently using Spring Boot 3.x, which is the latest stable version.
->It’s built on Spring Framework 6 and fully supports Jakarta EE 9+ (package names moved from javax.* to jakarta.*).
->Spring Boot 3 improves performance, security, and compatibility with Java 17+ (LTS version).
->It also supports AOT (Ahead-of-Time) compilation and GraalVM native image for faster startup and low memory usage.
->Dependency management is simplified with better observability (Micrometer, Prometheus, Grafana) support.
->I prefer using it because it’s modern, lightweight, and production-ready.
->However, in older projects, we sometimes use Spring Boot 2.7.x for backward compatibility with Java 8 or legacy systems.

I use Spring Boot 3.x because it’s the latest, faster, and optimized for Java 17+, offering better performance and observability.

12)Why Stream API in Java 8?
->The Stream API was introduced in Java 8 to process collections of data efficiently.
->Before Java 8, we used loops to iterate and filter data, which made code long, complex, and error-prone.
->Stream API allows declarative programming — you focus on what to do, not how to do it.
->It provides powerful methods like filter(), map(), sorted(), collect(), and reduce() for data transformation.
->It supports parallel processing using parallelStream(), improving performance on multi-core systems.
->Streams make code cleaner, readable, and maintainable with less boilerplate.
    Example:
   list.stream().filter(x -> x > 10).collect(Collectors.toList());
   — replaces several lines of loop code.

13)what is anonymous inner class and functional interface . differences ?
🧩Anonymous Inner Class
An anonymous inner class is a class without a name that is declared and instantiated at the same time.
It’s mainly used to override a method or provide implementation for an interface/class instantly.
Example (before Java 8):
Runnable r = new Runnable() {
    public void run() {
        System.out.println("Running...");
    }
};
It’s verbose — requires boilerplate code even for one-line logic.

🧩 Functional Interface
A Functional Interface has exactly one abstract method, marked with @FunctionalInterface.
It allows Lambda Expressions (introduced in Java 8) to provide implementation in a clean and concise way.
Example:
Runnable r = () -> System.out.println("Running...");
It’s lightweight, easier to read, and supports functional programming style.

14)can we call it a functional interface with 1 abstract method , default and static method?
✅ Yes, a Functional Interface can have one abstract method and any number of default or static methods.
->What defines it as functional is that it has exactly one abstract method — that’s what Lambda expressions implement.
->Default and static methods are not abstract, so they don’t break the functional interface rule.
Example:
@FunctionalInterface
interface MyInterface {
    void show();                    // abstract
    default void display() {}       // allowed
    static void print() {}          // allowed
}

->This interface is still functional because it has only one abstract method (show).
->You can still use it with a Lambda expression like:
MyInterface obj = () -> System.out.println("Hello!");
->Adding more than one abstract method will cause a compile-time error if it’s annotated with @FunctionalInterface

🧩 If we add more than one abstract method to a Functional Interface?
Adding more than one abstract method breaks the Functional Interface rule — it causes a compile-time error
if @FunctionalInterface is used and prevents Lambda usage.
Example:
@FunctionalInterface
interface MyInterface {
    void show();
    void display(); // ❌ Error – Multiple abstract methods
}
->Error: “Invalid '@FunctionalInterface' annotation; MyInterface is not a functional interface.”
->Without the annotation, the code compiles, but it cannot be used with a Lambda Expression.
->So the @FunctionalInterface annotation acts as a safety check to enforce the rule.

15)What is Deep Copy in Java?
->A Deep Copy means creating a completely independent copy of an object — including all the objects it references.
->In deep copy, the original and copied objects don’t share the same reference for nested objects.
->So, changes made in one object don’t affect the other.
   Example:
   class Address implements Cloneable {
       String city;
       public Address(String city) { this.city = city; }
       public Object clone() throws CloneNotSupportedException { return super.clone(); }
   }

   class Employee implements Cloneable {
       String name;
       Address address;
       public Employee(String name, Address address) {
           this.name = name; this.address = address;
       }
       public Object clone() throws CloneNotSupportedException {
           Employee e = (Employee) super.clone();
           e.address = (Address) address.clone(); // deep copy
           return e;
       }
   }

   Employee e1 = new Employee("Hari", new Address("Bangalore"));
   Employee e2 = (Employee) e1.clone();
   e2.address.city = "Chennai";
   System.out.println(e1.address.city); // Output: Bangalore ✅ (not affected)
->In deep copy, both e1 and e2 have separate Address objects.

->In contrast, a shallow copy copies only the top-level object — both share the same nested reference.
->The original and copy share the same reference for inner objects.
->Change in one object affects the other.
