1)What is comparable and comparator. And differences ?
-----------------------------------------------------------------
comparable is an interface and it is present in java.long package.
It is used to define natural order of objects.It has compareTo(Object o) method to compare current object with specific object.
Sorting logic is written in class it self so we have only one way to sort.
It is providing single sorting sequence and it will affects the original class.
It is sorting the list by default Id.
ex:- // Sorting using Comparable (by ID)
        Collections.sort(list);
        System.out.println("Sorted by ID (Comparable): " + list);

comparator is an interface and it is present in java.util package.
It is used to define custom sorting logic for different ways of sorting.
It has compare(Object o1, Object o2) method to compare 2 objects.
Sorting logic is written out side the class so we have multiple comparators for flexibility.
It is providing multiple sorting sequence and it will not affect the original class.
It is sorting the list by custom queries like by name, by salary...
ex:-// Sorting using Comparator (by Name)
       Collections.sort(list, Comparator.comparing(s -> s.name));
       System.out.println("Sorted by Name (Comparator): " + list);
‚úÖ Multiple Ways to Create a Comparator in Java
1.Separate Comparator class
class AgeComparator implements Comparator<Employee> { ... }
2.Anonymous inner class
new Comparator<Employee>() { ... }
3.Lambda expression
(e1, e2) -> e1.getAge() - e2.getAge()
4.Comparator.comparing()
Comparator.comparing(Employee::getName)


2)How to make class Immutable?
------------------------------------
Declare the class as final so it cannot be extended.
Make all fields private and final so we can prevent direct access and reassignment.
Don't provide setter method so fields cannot be changed after object creation.
Initialize all fields via constructor so we can ensure all values to set only once
For mutable objects like data , return copies in getters  so it will prevent external modifications.

ex:-
final class Student {
    private final int id;
    private final String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
    public int getId() { return id; }
    public String getName() { return name; }
}

3) How to connect DB from java application?
-----------------------------------------------
->Add JDBC Driver: Include the database driver (like MySQL, Oracle) in your project classpath.
->Load the Driver (Optional in Java 6+):
  Class.forName("com.mysql.cj.jdbc.Driver");
->Create a Connection: Use DriverManager.getConnection() with DB URL, username, and password.
->Create Statement / PreparedStatement: To execute SQL queries.
->Execute Query: Use executeQuery() for SELECT, executeUpdate() for INSERT/UPDATE/DELETE.
->Process Results: Read data from ResultSet (for SELECT queries).
->Close Resources: Close ResultSet, Statement, and Connection to avoid memory leaks.

Steps to connect DB in Spring Boot:
->Add database dependency (like MySQL) in pom.xml.
->Configure application.properties with URL, username, password, and driver.
->Create Entity class with @Entity and @Id.
->Create Repository interface by extending JpaRepository.
->Autowire repository in Service/Controller ‚Üí Spring Boot handles DB connection automatically.

4)Why Spring Boot?
->Simplifies setup: Auto configures spring applications with minimal boilerplate and xml
->Standalone Applications:Can run as a self contained jar for embedded tomcat, no need for external server.
->Faster Development: Reduces manual configurations; easy integration with Spring modules (JPA, Security, MVC).
->Production Ready: Built-in features like metrics, health checks, logging, and monitoring.
->Microservices Friendly: Ideal for building microservices with REST, messaging, and cloud integration.
->Opinionated Defaults: Provides default settings and conventions, so developers focus on business logic.
->Community & Ecosystem: Large community, lots of starters, libraries, and support for modern development.

‚úÖ Difference between Spring Framework and Spring Boot
->Spring Framework is the core framework that provides features like Dependency Injection, AOP, MVC, JDBC, and transaction management, but it requires a lot of manual configuration.
->It needs developers to set up XML/Java config, server setup (Tomcat), and dependency management manually.
->Spring Boot is built on top of Spring Framework and aims to make application development faster and easier using auto-configuration.
->Spring Boot removes boilerplate by providing defaults, embedded servers (Tomcat/Jetty), and starter dependencies.
->Spring Framework gives more control and flexibility, but setup is slower; Spring Boot gives convenience and rapid development with less code.
->Spring Boot creates production-ready apps with features like Actuator, health checks, and metrics out of the box.

In short: Spring = heavy configuration, more control. Spring Boot = minimal configuration, faster development, ready-to-run applications.

5)How to cover private methods in Java (JUnit testing)?
Private methods are not directly accessible from test classes. The best approach is to test private indirectly through
public methods which is calling private methods. This ensures behavior of the method testing , not the internal implementation.

If we want to test private methods directly them we can use reflection API to access private methods.

Public Method:-
---------------
üß© Example: Testing Private Method Indirectly
class Calculator {

    // Private method - not directly accessible
    private int add(int a, int b) {
        return a + b;
    }

    // Public method - calls the private method
    public int calculateSum(int x, int y) {
        return add(x, y);  // private method is tested here indirectly
    }
}

‚úÖ JUnit Test
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class CalculatorTest {

    @Test
    void testCalculateSum() {
        Calculator calc = new Calculator();
        int result = calc.calculateSum(5, 7);
        assertEquals(12, result); // indirectly tests 'add' method
    }
}

Reflection APi:-
---------------
public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        Calculator calc = new Calculator();

        // Get private method reference
        Method method = Calculator.class.getDeclaredMethod("multiply", int.class, int.class);

        // Make it accessible
        method.setAccessible(true);

        // Invoke the method
        int result = (int) method.invoke(calc, 5, 6);

        System.out.println("Result: " + result); // Output: 30
    }

üß© Why testing private methods directly is discouraged:
->Private methods are internal implementation details, not part of the class‚Äôs public behavior.
->When you test private methods directly, your tests become tightly coupled to internal logic ‚Äî even small code changes can break tests.
->It violates encapsulation, one of the main principles of OOP.
->Unit tests should focus on ‚Äúwhat‚Äù the class does (output), not ‚Äúhow‚Äù it does it (internal steps).
->Testing through public methods ensures you‚Äôre verifying real behavior, not private mechanics.
->Frameworks like Spring, JUnit, and Mockito also follow this design ‚Äî they never test private code directly.

6)What communication do you use in Microservices?
->Microservices communicate with each other using Inter-Service Communication.
->It can be Synchronous (real-time) or Asynchronous (event-based).
->For Synchronous communication, we use REST APIs over HTTP using tools like Feign Client, RestTemplate, or WebClient.
->For Asynchronous communication, we use Message Brokers like Kafka, RabbitMQ, or ActiveMQ.
->REST is preferred when services need an immediate response.
->Messaging (Kafka, RabbitMQ) is used when we want loose coupling, scalability, and reliability.

Feign Client is used in Spring Cloud microservices for easy, declarative service-to-service communication.
RestTemplate is used only in legacy applications for simple, blocking (synchronous) HTTP calls.
WebClient is used in modern Spring apps for both synchronous and reactive high-performance communication.

RabbitMQ is used where messages must be delivered quickly and reliably, one by one.
Perfect for chat apps, notifications, task queues, order processing, email services, etc.

Kafka is used where data is produced at very high volume and speed, and needs to be processed/streamed in real time.
Real-world places where Kafka is heavily used:
Netflix ‚Üí user activity tracking, recommendations
LinkedIn ‚Üí activity streams, analytics, feed updates
Uber ‚Üí real-time trip events, location tracking

7)What is Mock and Spy in Mockito?
->Mock and Spy are both used to create test doubles (fake objects) in unit testing.
->A Mock is a complete fake object ‚Äî all methods are stubbed by default (return null, 0, or false unless specified).
->We use when(...).thenReturn(...) to define its behavior.
->A Spy, on the other hand, wraps a real object ‚Äî it calls real methods unless you explicitly stub them.
->Mock is used when you want full control and don‚Äôt care about real logic.
->Spy is used when you want to test a partially real object (some real methods + some mocked).
Useful when object has complex logic and you want to test only part of it.
Useful when you want to call real methods but bypass one or two methods that are slow or dependent.
Good for testing service methods that internally call private/helper methods.
  Example:
  MyService mockService = Mockito.mock(MyService.class); // all fake
  MyService spyService = Mockito.spy(new MyService());   // real + fake mix

8)What are External Configurations and Profiles in Spring Boot?
->External Configuration means keeping application settings outside the code (e.g., database URL, username, passwords).
->These values are defined in application.properties or application.yml, or even in environment variables, command-line args, or config servers.
->It helps to avoid hardcoding values and makes applications easier to move across environments (dev, test, prod).
->Profiles are used to define environment-specific configurations.
->For example: application-dev.properties, application-test.properties, application-prod.properties.
  You can activate a profile using:
  spring.profiles.active=dev
->Based on the active profile, Spring Boot loads the corresponding configuration file automatically.

9)How to Remove Tomcat Server from a Spring Boot Application
->Spring Boot includes Tomcat as its default embedded web server (via spring-boot-starter-web).
->To remove Tomcat, you must exclude it from the starter dependency.
Example in pom.xml:

  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
      <exclusions>
          <exclusion>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-tomcat</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
->Then, you can add another server (like Jetty or Undertow) if needed.
  For Jetty, just add:
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jetty</artifactId>
  </dependency>
->If you want no embedded server at all (non-web app), use:
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
  </dependency>
 ->Finally, make sure your application class does not start a web context.

 10)Is it mandatory to have an Entity class to fetch data?
->If you are using JPA or Hibernate, then yes, it‚Äôs mandatory to have an Entity class.
->JPA works on the concept of Object-Relational Mapping (ORM) ‚Äî it maps Java objects (entities) to database tables.
->Without an entity, JPA won‚Äôt know which table or columns to map the data to.
->However, if you are using JDBC Template or native SQL queries, you can fetch data without an entity ‚Äî results come as List<Map<String, Object>> or custom DTOs.
->So, Entity is mandatory for ORM-based access, but not required for plain SQL-based access.
->Example: JdbcTemplate.queryForList("SELECT * FROM employee") doesn‚Äôt need an entity.
->But with JpaRepository<Employee, Long>, you must have @Entity class Employee.

11)Which version of Spring Boot are you using and why?
->I‚Äôm currently using Spring Boot 3.x, which is the latest stable version.
->It‚Äôs built on Spring Framework 6 and fully supports Jakarta EE 9+ (package names moved from javax.* to jakarta.*).
->Spring Boot 3 improves performance, security, and compatibility with Java 17+ (LTS version).
->It also supports AOT (Ahead-of-Time) compilation and GraalVM native image for faster startup and low memory usage.
->Dependency management is simplified with better observability (Micrometer, Prometheus, Grafana) support.
->I prefer using it because it‚Äôs modern, lightweight, and production-ready.
->However, in older projects, we sometimes use Spring Boot 2.7.x for backward compatibility with Java 8 or legacy systems.

I use Spring Boot 3.x because it‚Äôs the latest, faster, and optimized for Java 17+, offering better performance and observability.

12)Why Stream API in Java 8?
->The Stream API was introduced in Java 8 to process collections of data efficiently.
->Before Java 8, we used loops to iterate and filter data, which made code long, complex, and error-prone.
->Stream API allows declarative programming ‚Äî you focus on what to do, not how to do it.
->It provides powerful methods like filter(), map(), sorted(), collect(), and reduce() for data transformation.
->It supports parallel processing using parallelStream(), improving performance on multi-core systems.
->Streams make code cleaner, readable, and maintainable with less boilerplate.
    Example:
   list.stream().filter(x -> x > 10).collect(Collectors.toList());
   ‚Äî replaces several lines of loop code.

13)what is anonymous inner class and functional interface . differences ?
üß©Anonymous Inner Class
An anonymous inner class is a class without a name that is declared and instantiated at the same time.
It‚Äôs mainly used to override a method or provide implementation for an interface/class instantly.
Example (before Java 8):
Runnable r = new Runnable() {
    public void run() {
        System.out.println("Running...");
    }
};
It‚Äôs verbose ‚Äî requires boilerplate code even for one-line logic.

üß© Functional Interface
A Functional Interface has exactly one abstract method, marked with @FunctionalInterface.
It allows Lambda Expressions (introduced in Java 8) to provide implementation in a clean and concise way.
Example:
Runnable r = () -> System.out.println("Running...");
It‚Äôs lightweight, easier to read, and supports functional programming style.

14)can we call it a functional interface with 1 abstract method , default and static method?
‚úÖ Yes, a Functional Interface can have one abstract method and any number of default or static methods.
->What defines it as functional is that it has exactly one abstract method ‚Äî that‚Äôs what Lambda expressions implement.
->Default and static methods are not abstract, so they don‚Äôt break the functional interface rule.
Example:
@FunctionalInterface
interface MyInterface {
    void show();                    // abstract
    default void display() {}       // allowed
    static void print() {}          // allowed
}

->This interface is still functional because it has only one abstract method (show).
->You can still use it with a Lambda expression like:
MyInterface obj = () -> System.out.println("Hello!");
->Adding more than one abstract method will cause a compile-time error if it‚Äôs annotated with @FunctionalInterface

üß© If we add more than one abstract method to a Functional Interface?
Adding more than one abstract method breaks the Functional Interface rule ‚Äî it causes a compile-time error
if @FunctionalInterface is used and prevents Lambda usage.
Example:
@FunctionalInterface
interface MyInterface {
    void show();
    void display(); // ‚ùå Error ‚Äì Multiple abstract methods
}
->Error: ‚ÄúInvalid '@FunctionalInterface' annotation; MyInterface is not a functional interface.‚Äù
->Without the annotation, the code compiles, but it cannot be used with a Lambda Expression.
->So the @FunctionalInterface annotation acts as a safety check to enforce the rule.

Why We Use Functional Interface
A functional interface represents a single behavior or action in one place.
It allows us to use lambda expressions, making the code shorter and cleaner.
We use it to write more readable and expressive code, especially in Streams and functional programming.
1. Runnable
2. Callable
3. Comparator

15)What is Deep Copy & Shallow Copy in Java?
A deep copy creates a completely new object along with new copies of all nested objects.
Original and copied objects do not share any internal references.
Changes made in the copied nested objects do NOT affect the original object.
   Example:
   class Address implements Cloneable {
       String city;
       public Address(String city) { this.city = city; }
       public Object clone() throws CloneNotSupportedException { return super.clone(); }
   }

   class Employee implements Cloneable {
       String name;
       Address address;
       public Employee(String name, Address address) {
           this.name = name; this.address = address;
       }
       public Object clone() throws CloneNotSupportedException {
           Employee e = (Employee) super.clone();
           e.address = (Address) address.clone(); // deep copy
           return e;
       }
   }

   Employee e1 = new Employee("Hari", new Address("Bangalore"));
   Employee e2 = (Employee) e1.clone();
   e2.address.city = "Chennai";
   System.out.println(e1.address.city); // Output: Bangalore ‚úÖ (not affected)
->In deep copy, both e1 and e2 have separate Address objects.

What is Shallow Copy?
A shallow copy creates a new object, but it does not create copies of the inner objects.
It only copies the references, so both original and copied objects share the same internal objects.
If you change a nested object in the copy, the original will also change because both point to the same memory.

‚úÖ When to Use Deep Copy
Use deep copy when:
Your object has mutable nested objects (Lists, Maps, custom classes).
You don‚Äôt want changes in the copied object to affect the original.
You need full isolation between two objects.

‚úÖ When to Use Shallow Copy
Use shallow copy when:
Your object contains immutable fields (String, Integer, LocalDate, etc.).
Internal objects will not be modified after copying.
You want faster and lightweight copying.

16)JVM Architecture (Java Virtual Machine)
JVM (Java Virtual Machine) is the part of JRE responsible for executing Java bytecode.
It provides platform independence ‚Äî ‚ÄúWrite Once, Run Anywhere‚Äù.
The JVM architecture mainly consists of three components:
->Class Loader Subsystem
->Runtime Data Areas (Memory)
->Execution Engine

JVM loads bytecode using the Class Loader, stores data in Runtime Memory Areas,
and executes it using the Execution Engine with the help of the JIT Compiler and Garbage Collector.

17)Static keyword?
The static keyword in Java is used to define members (variables, methods, blocks, or nested classes) that belong to the class rather than to any specific object.
This means they can be accessed without creating an object of the class.
Static Variable: Shared among all objects of the class. Any change made by one object reflects in all others.
  static int count = 0;
Static Method: Can be called without creating an object. It cannot access non-static members directly.
  static void show() { System.out.println("Static Method"); }
Static Block: Executes once when the class is loaded ‚Äî often used for initializing static variables.
   static { System.out.println("Static Block Executed"); }
Static Class (Nested): A static nested class can be accessed without an instance of the outer class.

18)Can we use HashMap in Multi-threaded Environments?
No, a normal HashMap is not thread-safe and should not be used directly in a multi-threaded environment.
When multiple threads modify a HashMap at the same time (e.g., put() or resize()), it can lead to data inconsistency or even infinite loops.
To use maps safely across threads, Java provides thread-safe alternatives.
The main ones are:
ConcurrentHashMap ‚Üí Preferred in multithreading (high performance + safe).
Collections.synchronizedMap(new HashMap<>()) ‚Üí Synchronized but slower.

ConcurrentHashMap uses segment-level locking (or bucket-level in Java 8), allowing multiple threads to read/write concurrently.

Example:
Map<String, Integer> map = new ConcurrentHashMap<>();
map.put("Hari", 100);

Hence, HashMap is unsafe, but ConcurrentHashMap is the recommended choice for multi-threaded programs.

üß© What is ConcurrentHashMap in Java?
ConcurrentHashMap is a thread-safe version of HashMap introduced in Java 1.5 (in java.util.concurrent package).
It allows multiple threads to read and write concurrently without corrupting the data.
Unlike Hashtable or Collections.synchronizedMap(), it doesn‚Äôt lock the entire map ‚Äî it locks only a portion (bucket/segment).
This improves performance and reduces contention between threads.
In Java 8, it uses a fine-grained locking mechanism (using internal synchronized blocks and CAS ‚Äî Compare-And-Swap).
null keys and values are not allowed to avoid confusion during concurrent updates.
Example:
Map<String, Integer> map = new ConcurrentHashMap<>();
map.put("Hari", 100);
map.put("Kumar", 200);

It‚Äôs ideal for multi-threaded caching, counters, or real-time data sharing.

19)Difference Between HashMap and Hashtable
‚úÖ Simple Explanation:
HashMap implements Map ‚Üí It is non-synchronized, faster, and allows null keys & values.
Hashtable implements Map ‚Üí It is synchronized (thread-safe), slower, and does not allow null keys or values.
Both are different implementations of the same Map interface, but with different behaviors.

Synchronization:
   HashMap is not synchronized ‚Üí not thread-safe.
   Hashtable is synchronized ‚Üí thread-safe, but slower in single-threaded use.
Null Values:
   HashMap allows one null key and multiple null values.
   Hashtable doesn‚Äôt allow any null key or value (throws NullPointerException).
Performance:
   HashMap is faster because it‚Äôs non-synchronized.
   Hashtable is slower due to synchronization on every method.
Introduced In:
   HashMap ‚Üí Introduced in Java 1.2 (part of Collections Framework).
   Hashtable ‚Üí Introduced in Java 1.0 (legacy class, before Collections Framework).
Iterator Type:
   HashMap uses fail-fast iterators (throws ConcurrentModificationException).
   Hashtable uses enumeration, which is not fail-fast.
Usage Recommendation:
   Prefer HashMap for single-threaded or controlled concurrency.
   Use ConcurrentHashMap instead of Hashtable for multithreading.

20) Internal working of HashMap?

21)Spring Boot Internal Annotations
The main class of a Spring Boot app is annotated with @SpringBootApplication, which is a meta-annotation that combines three important annotations:
   @SpringBootApplication =
       @Configuration + @EnableAutoConfiguration + @ComponentScan
@Configuration ‚Üí Tells Spring that this class contains bean definitions using @Bean methods.
@EnableAutoConfiguration ‚Üí Enables Spring Boot‚Äôs auto-configuration feature, which automatically configures beans based on dependencies in the classpath (e.g., DataSource, DispatcherServlet, etc.).
@ComponentScan ‚Üí Scans the current package and sub-packages to find Spring components like @Component, @Service, @Repository, and @Controller.
Together, these annotations make Spring Boot apps ready-to-run with minimal configuration ‚Äî you just write the logic and Boot wires everything automatically.
Additional internal annotations used are:
   @RestController ‚Üí Combines @Controller + @ResponseBody.
   @SpringBootConfiguration ‚Üí Specialized form of @Configuration.

22)@CrossOrigin in Spring Boot
@CrossOrigin is used to enable Cross-Origin Resource Sharing (CORS) in Spring Boot applications.
CORS is a browser security mechanism that restricts web pages from making requests to a different domain or port (for example, React app on localhost:3000 calling Spring Boot API on localhost:8080).
By default, browsers block such cross-origin requests for security reasons.
Using @CrossOrigin, we tell Spring Boot to allow requests from specific origins.
   @CrossOrigin(origins = "http://localhost:3000")
   @RestController
   public class EmployeeController { ... }
You can apply it at class level (for all APIs in the controller) or method level (for specific endpoints).
It supports extra attributes like methods, allowedHeaders, and maxAge to fine-tune CORS behavior.
If not configured, your frontend may get a CORS error like ‚ÄúAccess to fetch at ... has been blocked by CORS policy.‚Äù

23)Difference between @Controller and @RestController
@Controller is used in Spring MVC to handle web requests and return views (like JSP, Thymeleaf pages).
@RestController is introduced in Spring Boot (Spring 4) to simplify building RESTful web services that return JSON or XML data.
@RestController is basically a shortcut for @Controller + @ResponseBody.
When you use @Controller, you need to manually add @ResponseBody on methods if you want to return data (not view).
When you use @RestController, every method by default returns the response body directly (e.g., JSON) ‚Äî no view rendering.
  Example:
    @Controller
   public class MyController {
       @GetMapping("/home")
       public String home() { return "index"; } // returns view name
   }

   we can use produces = MediaType.APPLICATION_XML_VALUE in getmapping to return xml or json type values based on requirements.
    @GetMapping(value = "/employee", produces = MediaType.APPLICATION_XML_VALUE)

   @RestController
   public class MyRestController {
       @GetMapping("/user")
       public User getUser() { return new User("Hari", 30); } // returns JSON
   }
So, use @Controller for web apps (UI) and @RestController for APIs (data exchange).

24)Stereotype Annotations in Spring
Stereotype annotations are specialized annotations in Spring used to define the roles of classes in the application context.
They tell Spring which classes should be automatically detected during component scanning and registered as Spring Beans.
The main stereotype annotations are:
   @Component ‚Üí Generic annotation for any Spring-managed bean.
   @Service ‚Üí Marks a class that holds business logic.
   @Repository ‚Üí Marks a DAO layer or data access class; adds extra exception translation.
   @Controller ‚Üí Used in web MVC layer to handle web requests.
All these annotations are specializations of @Component, meaning they behave like components but are used for better readability and layered architecture.
They help Spring perform component scanning automatically when @ComponentScan is used.

25)Segregation of Stereotype vs Non-Stereotype Annotations
Stereotype annotations are those that define the role of a class in the Spring application and allow automatic bean detection through component scanning.
Examples: @Component, @Service, @Repository, @Controller, and @RestController.
These annotations are applied at the class level and tell Spring to create and manage the object in its ApplicationContext.
Non-stereotype annotations do not create beans by themselves ‚Äî instead, they add behavior, configuration, or metadata to existing beans.
Examples: @Autowired, @Value, @Qualifier, @Bean, @Configuration, @Primary, @Transactional.
   Stereotype ‚Üí "What kind of bean this class is."
   Non-stereotype ‚Üí "How this bean behaves or interacts."
In short:
   Stereotype = Bean definition (class-level)
   Non-stereotype = Bean behavior/configuration (method or field-level)

26)How to Configure a Database in Spring Boot
Spring Boot provides auto-configuration for databases ‚Äî you just add the JDBC or JPA dependency and define connection details in application.
properties or application.yml.
   Example (application.properties):
   spring.datasource.url=jdbc:mysql://localhost:3306/employee_db
   spring.datasource.username=root
   spring.datasource.password=root123
   spring.jpa.hibernate.ddl-auto=update
   spring.jpa.show-sql=true

When the app starts, Spring Boot automatically creates a DataSource, connects to the DB, and configures JPA/Hibernate if dependencies are present.
You can also use @Entity classes and JpaRepository interfaces to perform CRUD operations without writing SQL.
Optionally, you can define profiles (like dev, test, prod) with different DB configs using application-dev.properties.
If you want to manually configure, you can use a @Configuration class and define a DataSource bean using @Bean.

27)Default Spring Boot Dependencies
When you create a Spring Boot project (using Spring Initializr), it automatically adds default dependencies through the spring-boot-starter modules.
The most common default dependency is:
   spring-boot-starter ‚Üí includes core Spring, logging (Logback + SLF4J), and auto-configuration support.

Other frequently included starters (based on project type):
   spring-boot-starter-web ‚Üí for REST APIs (includes Spring MVC, Jackson, Tomcat).
   spring-boot-starter-data-jpa ‚Üí for database access (includes Hibernate + JPA).
   spring-boot-starter-test ‚Üí for unit and integration testing (JUnit, Mockito).

These starters bundle multiple libraries, reducing the need to manage versions manually.
Spring Boot manages all compatible versions through Spring Boot Parent (spring-boot-dependencies) in the POM.
This ensures version consistency, faster setup, and no dependency conflicts.

28)Internal Methods of Stream API
The Stream API internally works using two types of operations:
   Intermediate Operations
   Terminal Operations
Intermediate methods ‚Üí return a new Stream and are lazy, meaning they don‚Äôt execute until a terminal operation is called.
   Examples: filter(), map(), sorted(), distinct(), limit(), skip().
Terminal methods ‚Üí trigger the processing of the stream and produce a result or side effect.
   Examples: collect(), forEach(), reduce(), count(), findFirst(), anyMatch().
Internally, the Stream API uses Spliterator and Pipeline concepts ‚Äî data flows in a chain through these methods.
Each intermediate method adds a stage to the pipeline, and terminal operations trigger the execution of all stages together.
Stream API internally uses functional interfaces (like Predicate, Function, Consumer) to define its logic.

29)about DSA?

30)Difficulties Faced in My Project
One major challenge I faced was handling data consistency across multiple microservices while processing real-time transactions.
Since each service had its own database, maintaining atomicity and rollback in case of partial failures was tricky.
We solved it using Kafka for event-driven communication and Saga Pattern for managing distributed transactions.
Another challenge was debugging production issues ‚Äî we used tools like Splunk, Grafana, and Dynatrace to trace logs and monitor performance.
I also faced connection timeout and slow query issues in DB2, which we fixed by optimizing queries and configuring connection pools.
During deployments, version mismatches between services caused failures ‚Äî we overcame this using Git branching strategy and CI/CD validation.
These challenges taught me how to design fault-tolerant, scalable, and maintainable microservices.

31)How to Generate a Primary Key in Spring Boot (JPA)
In Spring Data JPA, we use the annotation @Id to mark a field as the primary key in the entity class.
To make it auto-generated, we add @GeneratedValue along with a generation strategy.
   Example:
   @Entity
   public class Employee {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String name;
   }
The strategy attribute defines how the primary key is generated:
   IDENTITY ‚Üí Auto-increment (DB handles it).
   SEQUENCE ‚Üí Uses a database sequence (common in Oracle, PostgreSQL).
   TABLE ‚Üí Uses a separate table to store sequence values.
   AUTO ‚Üí Lets JPA decide the best strategy based on the database.
You can also define a custom sequence using @SequenceGenerator if your DB supports it.
For non-relational DBs or manual control, you can assign IDs programmatically before saving.

32)What is JWT (JSON Web Token)?
JWT stands for JSON Web Token, which is a secure, compact way to transmit user information between two parties ‚Äî usually client and server.
It is mainly used for authentication and authorization in modern applications (especially in REST APIs).
A JWT is a digitally signed token that confirms the user‚Äôs identity and allows access to protected resources without storing session data on the server.
A JWT consists of three parts:
   Header ‚Üí contains the algorithm & token type.
   Payload ‚Üí contains user details and claims (like username, roles).
   Signature ‚Üí ensures data integrity (using a secret key or RSA key).
Flow: After successful login, the server generates a JWT ‚Üí sends it to the client ‚Üí client includes it in every request‚Äôs Authorization header.
Server validates the signature before allowing access ‚Äî no need to query the DB each time.
JWT helps achieve stateless authentication in Spring Boot microservices.

33)Authentication vs Authorization
Authentication is the process of verifying the user‚Äôs identity ‚Äî confirming who the user is (like username and password validation).
Authorization is the process of checking what actions or resources that user is allowed to access (like admin vs normal user).
   In simple terms:
   Authentication ‚Üí ‚ÄúWho are you?‚Äù
   Authorization ‚Üí ‚ÄúWhat can you do?‚Äù
Example: When you log into a banking app ‚Üí login step = Authentication, viewing only your account and not others‚Äô = Authorization.
In Spring Security, authentication is handled by AuthenticationManager and UserDetailsService.
Authorization is managed through roles and authorities, usually with annotations like @PreAuthorize("hasRole('ADMIN')") or @Secured.
Both processes often work together ‚Äî you must be authenticated first before authorization can be applied.

34)what are custom exceptions? can we create at run time?
Custom Exceptions are user-defined exceptions that extend either the Exception class (for checked exceptions) or the RuntimeException class (for unchecked exceptions).
They are created when the built-in Java exceptions (like NullPointerException, IOException, etc.) don‚Äôt clearly describe a specific error condition in your application.
‚úÖ Can we create them at runtime?
Yes ‚Äî exceptions (including custom ones) are always thrown at runtime using the throw keyword.
You define the class once, but the actual creation (new InvalidAgeException(...)) happens dynamically during program execution when a specific condition fails.

35)what is @Autowired?
The @Autowired annotation in Spring is used for automatic dependency injection.
It tells Spring to automatically provide (inject) the required bean into a class without needing to create it manually using new.

36)How to set server port?
By default, the Spring Boot application runs on port 8080.
1. Using application.properties
Add this line in your src/main/resources/application.properties file:
server.port=8081
‚û°Ô∏è This sets the application to run on port 8081 instead of the default 8080.

2. Using application.yml
If you use YAML configuration:
server:
  port: 8081

37)How to make war files from spring boot?
To create a WAR (Web Application Archive) file from a Spring Boot application (instead of the default JAR),
1. Change Packaging Type
In your pom.xml, change:
<packaging>jar</packaging>
to:
<packaging>war</packaging>

2.Extend SpringBootServletInitializer
In your main class, extend SpringBootServletInitializer and override configure():
  @SpringBootApplication
  public class MyApp extends SpringBootServletInitializer {

      @Override
      protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
          return builder.sources(MyApp.class);
      }

      public static void main(String[] args) {
          SpringApplication.run(MyApp.class, args);
      }
  }

38)Basic dependencies for spring boot?
In a Spring Boot project, some basic dependencies are required to get your application up and running smoothly.
These dependencies are added in your pom.xml (for Maven).
spring-boot-starter
spring-boot-starter-web
spring-boot-starter-data-jpa
Database driver (like MySQL)
spring-boot-starter-test

39)Dereference b/w spring and spring boot?
üå± Spring Framework
It is a comprehensive framework for building Java enterprise applications.
Requires manual configuration (XML or Java-based) for beans, dependencies, and web.xml setup.
You need to set up servers manually (like Tomcat) to deploy your app.
Provides many modules (Spring MVC, AOP, JDBC, Security, etc.), but you must configure them yourself.
More boilerplate code and setup effort.
Focuses on flexibility but needs developer effort to integrate dependencies.

‚ö° Spring Boot
It is a simplified extension of Spring that makes application development faster and easier.
Uses auto-configuration ‚Äî Spring Boot automatically configures beans and settings based on dependencies.
Comes with an embedded server (like Tomcat or Jetty), so no need for external deployment.
Supports starters (spring-boot-starter-web, etc.) to easily include common dependencies.
Provides Spring Boot CLI and Actuator for monitoring and management.
Focuses on convention over configuration, reducing boilerplate and setup time.

40)modules in spring framework?
Spring Framework modules are grouped into:
->Core Container
->AOP
->Data Access / Integration
->Web
->Security
->Test

1. Core Container Module
Includes: spring-core, spring-beans, spring-context, spring-expression (SpEL)

2. Spring AOP (Aspect-Oriented Programming) Module
Purpose: Enables separating cross-cutting concerns like logging, transactions, or security using aspects.
Works with annotations like @Aspect and @Before.

3. Spring Data Access / Integration
Includes:
spring-jdbc ‚Äì Simplifies database access.
spring-tx ‚Äì Manages transactions.
spring-orm ‚Äì Integrates with ORM frameworks like Hibernate, JPA.
spring-oxm ‚Äì Supports Object/XML mapping.
spring-jms ‚Äì Messaging support with JMS.

4. Spring Web Module
Includes: spring-web, spring-webmvc

41)Common Annotations Used in Junit Testing?
| Annotation   | Purpose                    |
| ------------ | -------------------------- |
| @Test        | Marks a test case          |
| @BeforeEach  | Runs before every test     |
| @AfterEach   | Runs after every test      |
| @BeforeAll   | Runs once before all tests |
| @AfterAll    | Runs once after all tests  |
| @DisplayName | Gives custom test name     |
| @Disabled    | Skips the test temporarily |

üß© Difference between @BeforeEach and @BeforeAll
@BeforeEach runs before every test method, while @BeforeAll runs only once before all tests in the class.
@BeforeEach is used for test-level setup, like creating fresh objects for each test to ensure independence.
@BeforeAll is used for global setup, like loading configuration, initializing a database, or setting up a connection.
Methods annotated with @BeforeEach are non-static, but @BeforeAll methods must be static (in JUnit 5).
@BeforeEach ensures isolation of tests, while @BeforeAll improves performance by doing one-time initialization.

‚úÖ Example:
@BeforeAll
static void setupAll() { System.out.println("Run once before all tests"); }

@BeforeEach
void setupEach() { System.out.println("Run before each test"); }

üß© Mockito Annotations (Used for Unit Testing)
1. @Mock
The @Mock annotation is used to create a fake (mock) object of a class or interface.
It doesn‚Äôt call real methods ‚Äî instead, it mimics the behavior you define using when(...).thenReturn(...).
It helps isolate the class you‚Äôre testing by avoiding real dependencies (like DB or API calls).
Example: mocking a repository so your service logic can be tested independently.
It‚Äôs initialized automatically when you use @ExtendWith(MockitoExtension.class).
‚úÖ In short: Used to simulate objects and their behavior without real implementation.

2. @InjectMocks
@InjectMocks is used in Mockito to create an object of the class being tested.
It automatically injects all dependencies into that object using @Mock or @Spy.
It performs constructor injection, then setter injection, and finally field injection.
This annotation helps you test a class without manually creating dependencies.
It ensures your test focuses only on the business logic, not object creation.

3. @Spy
The @Spy annotation creates a partial mock ‚Äî a mix of real and fake behavior.
Unlike @Mock, it calls real methods unless you explicitly stub them.
Useful when you want to test some real logic but skip or control certain method calls.
Example: spying on a real list to test behavior while stubbing size() method.
It provides flexibility between real and mock objects.
‚úÖ In short: Calls real methods but allows selective mocking.

4. @Captor
The @Captor annotation is used to capture arguments that were passed to a mock method.
It helps verify what values were actually sent during a method call.
You use it along with verify() to assert parameters.
Example: verifying if a specific Employee object was passed to save(employee).
It improves test readability compared to using ArgumentCaptor.forClass().
‚úÖ In short: Used to capture and verify arguments passed to mocked methods.

5. @MockBean
@MockBean is a Spring Boot-specific annotation (not pure JUnit).
It adds a mock version of a bean to the Spring ApplicationContext.
This mock replaces the real bean ‚Äî perfect for integration testing controllers or services.
Commonly used in tests annotated with @SpringBootTest or @WebMvcTest.
It allows Spring to autowire the mock instead of a real implementation.
‚úÖ In short: Mocks a Spring bean inside the application context.

6. @ExtendWith(MockitoExtension.class)
Enables Mockito support in JUnit 5 test classes.
It automatically initializes annotations like @Mock, @Spy, and @InjectMocks.
Without this annotation, mocks would remain null.
It‚Äôs the replacement for MockitoAnnotations.openMocks(this) used in older JUnit versions.
It must be added at the class level.
‚úÖ In short: Integrates Mockito with JUnit 5 test execution.

42)Common Bugs Found in SonarQube
In my project, SonarQube commonly flagged issues like null pointer dereference, unclosed resources, empty catch blocks, hardcoded credentials, and high-complexity methods.
I resolved them by adding proper null checks, using try-with-resources, moving configs to external files, and refactoring long methods.
This helped improve our code maintainability and reduced technical debt.

=>Null Pointer Dereference ‚Äì
When a variable might be null and is used without a null check.
üß† Example:
String name = null;
System.out.println(name.length()); // Possible NullPointerException

=>Resource Leak ‚Äì
When resources like files, streams, or connections are opened but not closed properly.
üß† Example:
FileInputStream fis = new FileInputStream("file.txt");
// Missing fis.close();

=>Unreachable Code ‚Äì
Code that will never be executed (like statements after a return or throw).

=>Infinite Recursion or Loop ‚Äì
Recursive methods or loops with no proper exit condition.

=>Wrong String Comparison ‚Äì
Using == instead of .equals() to compare strings in Java.

=>Unused Variables or Imports ‚Äì
Declaring variables or imports that are never used in the code.

=>Empty Catch Blocks ‚Äì
Catching exceptions without handling or logging them (swallowing exceptions).

43)What is a Partition?
A partition means dividing a larger dataset or memory or storage into smaller, manageable parts (partitions)
‚Äî each part can be handled, processed, or stored separately.

44)can we create object for abstract class?
No, we cannot create an object (instance) of an abstract class directly.
Because an abstract class is incomplete ‚Äî it may have abstract methods (methods without a body), so the JVM cannot instantiate it.
Example:
abstract class Animal {
    abstract void sound();
}
Animal a = new Animal(); // ‚ùå Not allowed ‚Äî compile-time error

But we can create an object of a subclass
If a concrete subclass extends the abstract class and provides implementations for all abstract methods,
then we can create an object of that subclass.
class Dog extends Animal {
    void sound() {
        System.out.println("Bark");
    }
}
Animal a = new Dog(); // ‚úÖ Allowed
a.sound(); // Output: Bark

45)what are wrapper classes, uses, why?
What are Wrapper Classes?
Wrapper classes in Java are object representations of primitive data types.
They ‚Äúwrap‚Äù primitive values (like int, char, boolean) into objects so they can be used in collections, generics, and OOP operations.

Example:
int a = 10;
Integer num = Integer.valueOf(a); // Wrapping int into Integer object

=>Why are Wrapper Classes Used?
For Collections ‚Äì Collections (like ArrayList, HashMap) only store objects, not primitives.
For Generics ‚Äì Generics require object types (List<Integer> not List<int>).
For Utility Methods ‚Äì Wrapper classes have useful methods like parseInt(), toString(), etc.
For Autoboxing & Unboxing ‚Äì Java automatically converts primitives ‚Üî objects when needed.

Example:
Integer num = 5; // Autoboxing (int ‚Üí Integer)
int x = num;     // Unboxing (Integer ‚Üí int)

45)@Transactional
@Transactional is used in Spring to manage database transactions automatically.
It ensures that all the operations inside a method run in one single transaction.
If any exception occurs, Spring will roll back all the changes to maintain data consistency.
If the method completes successfully, it will commit the transaction.
It helps avoid partial updates and maintains ACID properties.
We usually apply it on service layer methods that involve multiple DB operations.

46)What is Circular Dependency?
Circular dependency happens when Bean A depends on Bean B, and Bean B also depends on Bean A.
Spring tries to create Bean A, but it needs Bean B; then it tries Bean B, but it again needs Bean A ‚Äî causing a loop.
This results in a BeanCurrentlyInCreationException or startup failure.

‚úÖ Real-Time Example: Circular Dependency
1. Service calling each other
OrderService calls PaymentService to process a payment.
PaymentService again calls OrderService to update order status.
Both services depend on each other ‚Üí circular dependency.

‚úÖ How to Manage Circular Dependencies
=>Use Setter Injection instead of Constructor Injection
  Constructor injection makes circular dependency impossible (both require each other immediately).
  Setter injection lets Spring create beans first and inject later, breaking the loop.

=>Use @Lazy on one of the dependencies
  @Lazy loads the bean only when needed, so the second bean gets created without immediately needing the first.

=>Introduce Events / Messaging
  For real-time apps, instead of calling each other directly:
  OrderService publishes an event (OrderPlaced)
  PaymentService listens and processes it
  No direct dependency ‚Üí no circular issue.

47)Difference between @Inject and @Autowired (6 lines)
   @Autowired is a Spring-specific annotation used for dependency injection.
   @Inject is a Java standard (JSR-330) annotation and not tied to Spring.
   @Autowired supports features like required = false and can inject lists, maps, etc.
   @Inject does not support Spring-specific options but works the same for basic DI.
   Both can inject through constructor, setter, and field injection.
   In Spring Boot projects, both behave almost the same, but @Autowired is more commonly used.

48)What is @Transient in JPA? (6‚Äì7 lines)
   @Transient is a JPA annotation used to mark a field in an entity class that should not be persisted in the database.
   When a field is annotated with @Transient, JPA ignores it during insert, update, and select operations.
   It is mainly used for fields that are required only for business logic, temporary calculations, or values derived at runtime.
   These fields are still part of the Java object but are not mapped to any column in the table.
   This helps in keeping the entity clean without changing the actual database schema.
   It is different from the transient keyword in Java, which is used for serialization, while @Transient is specifically for JPA persistence.

49)ORM (Object Relational Mapping)
ORM is a technique that allows Java objects to be mapped to database tables automatically.
It removes the need to write manual SQL queries for basic CRUD operations.
ORM frameworks (like Hibernate, JPA) convert Java classes into DB tables and class fields into table columns.
It helps developers work with databases using objects instead of SQL, improving productivity.
ORM also manages relationships, transactions, caching, and lazy loading automatically.
This makes the application cleaner, reduces boilerplate code, and avoids SQL-related errors.

50)How We Implement Caching?
   Caching means storing frequently accessed data in memory so the application doesn‚Äôt hit the database every time.
   In Spring Boot, we implement caching by enabling @EnableCaching in the main class and using @Cacheable on methods.
   When a method with @Cacheable is called, the result is stored in a cache (like ConcurrentMapCache, Redis, Ehcache).
   Next time the same method is called with the same input, Spring returns the value from cache instead of executing method logic.
   We use @CachePut to update the cache and @CacheEvict to remove old/stale data.
   For distributed systems or microservices, Redis is commonly used as an external cache store.
   Caching improves performance, reduces DB load, and speeds up API responses.

51)

