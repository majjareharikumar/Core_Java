1)What is comparable and comparator. And differences ?
-----------------------------------------------------------------
comparable is an interface and it is present in java.long package.
It is used to define natural order of objects.It has compareTo(Object o) method to compare current object with specific object.
Sorting logic is written in class it self so we have only one way to sort.
It is providing single sorting sequence and it will affects the original class.
It is sorting the list by default Id.
ex:- // Sorting using Comparable (by ID)
        Collections.sort(list);
        System.out.println("Sorted by ID (Comparable): " + list);

comparator is an interface and it is present in java.util package.
It is used to define custom sorting logic for different ways of sorting.
It has compare(Object o1, Object o2) method to compare 2 objects.
Sorting logic is written out side the class so we have multiple comparators for flexibility.
It is providing multiple sorting sequence and it will not affect the original class.
It is sorting the list by custom queries like by name, by salary...
ex:-// Sorting using Comparator (by Name)
       Collections.sort(list, Comparator.comparing(s -> s.name));
       System.out.println("Sorted by Name (Comparator): " + list);

2)How to make class Immutable?
------------------------------------
Declare the class as final so it cannot be extended.
Make all fields private and final so we can prevent direct access and reassignment.
Don't provide setter method so fields cannot be changed after object creation.
Initialize all fields via constructor so we can ensure all values to set only once
For mutable objects like data , return copies in getters  so it will prevent external modifications.

ex:-
final class Student {
    private final int id;
    private final String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
    public int getId() { return id; }
    public String getName() { return name; }
}

3) How to connect DB from java application?
-----------------------------------------------
->Add JDBC Driver: Include the database driver (like MySQL, Oracle) in your project classpath.
->Load the Driver (Optional in Java 6+):
  Class.forName("com.mysql.cj.jdbc.Driver");
->Create a Connection: Use DriverManager.getConnection() with DB URL, username, and password.
->Create Statement / PreparedStatement: To execute SQL queries.
->Execute Query: Use executeQuery() for SELECT, executeUpdate() for INSERT/UPDATE/DELETE.
->Process Results: Read data from ResultSet (for SELECT queries).
->Close Resources: Close ResultSet, Statement, and Connection to avoid memory leaks.

Steps to connect DB in Spring Boot:
->Add database dependency (like MySQL) in pom.xml.
->Configure application.properties with URL, username, password, and driver.
->Create Entity class with @Entity and @Id.
->Create Repository interface by extending JpaRepository.
->Autowire repository in Service/Controller → Spring Boot handles DB connection automatically.

4)Why Spring Boot?
->Simplifies setup: Auto configures spring applications with minimal boilerplate and xml
->Standalone Applications:Can run as a self contained jar for embedded tomcat, no need for external server.
->Faster Development: Reduces manual configurations; easy integration with Spring modules (JPA, Security, MVC).
->Production Ready: Built-in features like metrics, health checks, logging, and monitoring.
->Microservices Friendly: Ideal for building microservices with REST, messaging, and cloud integration.
->Opinionated Defaults: Provides default settings and conventions, so developers focus on business logic.
->Community & Ecosystem: Large community, lots of starters, libraries, and support for modern development.

5)How to cover private methods in Java (JUnit testing)?
Private methods are not directly accessible from test classes. The best approach is to test private indirectly through
public methods which is calling private methods. This ensures behavior of the method testing , not the internal implementation.

If we want to test private methods directly them we can use reflection API to access private methods.

Public Method:-
---------------
🧩 Example: Testing Private Method Indirectly
class Calculator {

    // Private method - not directly accessible
    private int add(int a, int b) {
        return a + b;
    }

    // Public method - calls the private method
    public int calculateSum(int x, int y) {
        return add(x, y);  // private method is tested here indirectly
    }
}

✅ JUnit Test
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class CalculatorTest {

    @Test
    void testCalculateSum() {
        Calculator calc = new Calculator();
        int result = calc.calculateSum(5, 7);
        assertEquals(12, result); // indirectly tests 'add' method
    }
}

Reflection APi:-
---------------
public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        Calculator calc = new Calculator();

        // Get private method reference
        Method method = Calculator.class.getDeclaredMethod("multiply", int.class, int.class);

        // Make it accessible
        method.setAccessible(true);

        // Invoke the method
        int result = (int) method.invoke(calc, 5, 6);

        System.out.println("Result: " + result); // Output: 30
    }

🧩 Why testing private methods directly is discouraged:
->Private methods are internal implementation details, not part of the class’s public behavior.
->When you test private methods directly, your tests become tightly coupled to internal logic — even small code changes can break tests.
->It violates encapsulation, one of the main principles of OOP.
->Unit tests should focus on “what” the class does (output), not “how” it does it (internal steps).
->Testing through public methods ensures you’re verifying real behavior, not private mechanics.
->Frameworks like Spring, JUnit, and Mockito also follow this design — they never test private code directly.

6)What communication do you use in Microservices?
->Microservices communicate with each other using Inter-Service Communication.
->It can be Synchronous (real-time) or Asynchronous (event-based).
->For Synchronous communication, we use REST APIs over HTTP using tools like Feign Client, RestTemplate, or WebClient.
->For Asynchronous communication, we use Message Brokers like Kafka, RabbitMQ, or ActiveMQ.
->REST is preferred when services need an immediate response.
->Messaging (Kafka, RabbitMQ) is used when we want loose coupling, scalability, and reliability.
->In real projects, a mix of both is used — REST for direct calls, Kafka for event-driven communication.

7)What is Mock and Spy in Mockito?
->Mock and Spy are both used to create test doubles (fake objects) in unit testing.
->A Mock is a complete fake object — all methods are stubbed by default (return null, 0, or false unless specified).
->We use when(...).thenReturn(...) to define its behavior.
->A Spy, on the other hand, wraps a real object — it calls real methods unless you explicitly stub them.
->Mock is used when you want full control and don’t care about real logic.
->Spy is used when you want to test a partially real object (some real methods + some mocked).
  Example:
  MyService mockService = Mockito.mock(MyService.class); // all fake
  MyService spyService = Mockito.spy(new MyService());   // real + fake mix

8)What are External Configurations and Profiles in Spring Boot?
->External Configuration means keeping application settings outside the code (e.g., database URL, username, passwords).
->These values are defined in application.properties or application.yml, or even in environment variables, command-line args, or config servers.
->It helps to avoid hardcoding values and makes applications easier to move across environments (dev, test, prod).
->Profiles are used to define environment-specific configurations.
->For example: application-dev.properties, application-test.properties, application-prod.properties.
  You can activate a profile using:
  spring.profiles.active=dev
->Based on the active profile, Spring Boot loads the corresponding configuration file automatically.

9)How to Remove Tomcat Server from a Spring Boot Application
->Spring Boot includes Tomcat as its default embedded web server (via spring-boot-starter-web).
->To remove Tomcat, you must exclude it from the starter dependency.
Example in pom.xml:

  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
      <exclusions>
          <exclusion>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-tomcat</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
->Then, you can add another server (like Jetty or Undertow) if needed.
  For Jetty, just add:
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jetty</artifactId>
  </dependency>
->If you want no embedded server at all (non-web app), use:
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
  </dependency>
 ->Finally, make sure your application class does not start a web context.

 10)Is it mandatory to have an Entity class to fetch data?
->If you are using JPA or Hibernate, then yes, it’s mandatory to have an Entity class.
->JPA works on the concept of Object-Relational Mapping (ORM) — it maps Java objects (entities) to database tables.
->Without an entity, JPA won’t know which table or columns to map the data to.
->However, if you are using JDBC Template or native SQL queries, you can fetch data without an entity — results come as List<Map<String, Object>> or custom DTOs.
->So, Entity is mandatory for ORM-based access, but not required for plain SQL-based access.
->Example: JdbcTemplate.queryForList("SELECT * FROM employee") doesn’t need an entity.
->But with JpaRepository<Employee, Long>, you must have @Entity class Employee.
