What is Stream API?
--------------------
The Stream API in Java 8 is used to process collections of objects in a functional and declarative style.
Before Java 8, we relied on loops and iterators, which made the code verbose, complex, and difficult to maintain.
Writing parallel code was also error-prone and required manual thread handling.
Stream API solves these problems by providing built-in methods like filter(), map(), reduce(), and collect() for easy data manipulation.
It focuses on what to do rather than how to do it, making the code clean and readable.
Streams also support parallel execution, allowing better performance on multi-core processors.
In short, Stream API was introduced to simplify collection processing, reduce boilerplate code, and enable efficient parallel data operations.

How stream API will work?
------------------------------
Stream from source-->Intermediate operations(filter(), map(), or sorted())--->Terminal Operations(collect(), forEach(), or reduce() )
The Stream API in Java 8 works in three main steps.
1)First, a stream is created from a data source like a collection, array, or I/O channel.
2)Next, we apply intermediate operations such as filter(), map(), or sorted(), that transform or filter the stream and return another stream as the result.
3)Finally, a terminal operation like collect(), forEach(), or reduce() triggers the execution of the pipeline and produces the result.
Once a terminal operation is executed, the stream cannot be reused.
Streams can also be converted to parallel streams for faster processing using multiple CPU cores.
In short, Stream API works as a pipeline that transforms and processes data in a clean and efficient way.

A stream can be consumed only once. After a terminal operation, it is closed, and reusing it will throw IllegalStateException.
To reuse, create a new stream from the data source.

ðŸ”¹ What are Intermediate Operations in Stream API?
------------------------------------------------------
Intermediate operations are the operations in the Stream API that transform or filter the stream and return another stream as the result.
ðŸ”¹ Complete List of Intermediate Operations in Java Stream API
->filter(Predicate) â†’ Filters elements based on condition.
->map(Function) â†’ Transforms each element.
->mapToInt(ToIntFunction) / mapToLong / mapToDouble â†’ Specialized mapping to primitive streams.
->flatMap(Function) â†’ Flattens nested streams.
->flatMapToInt / flatMapToLong / flatMapToDouble â†’ Flatten into primitive streams.
->distinct() â†’ Removes duplicates.
->sorted() / sorted(Comparator) â†’ Sorts stream.
->peek(Consumer) â†’ Performs action (mainly debugging).
->limit(long n) â†’ Restricts to first n elements.
->skip(long n) â†’ Skips first n elements.

ðŸ”¹ What do Terminal Operations do in Stream API?
------------------------------------------------------
Terminal operations are the final step in a stream pipeline.
They trigger the execution of all the intermediate operations defined earlier.
Once a terminal operation is applied, the stream is considered consumed and cannot be reused.
These operations produce a final result such as a value (min, max, count), a collection (collect), or a side effect (forEach).
Examples include forEach(), collect(), reduce(), count(), min(), max(), findFirst(), anyMatch(), etc.
Without a terminal operation, the intermediate operations are never executed because they are lazy.
ðŸ”¹ Complete List of Terminal Operations
->forEach(Consumer) â€“ perform action on each element
->forEachOrdered(Consumer) â€“ ordered version of forEach (important in parallel streams)
->toArray() / toArray(IntFunction) â€“ collect elements into array
->reduce(BinaryOperator) / reduce(identity, accumulator) / reduce(identity, accumulator, combiner) â€“ reduce elements to a single result
->collect(Collector) â€“ collect into List, Set, Map, etc.
->min(Comparator) â€“ minimum element
->max(Comparator) â€“ maximum element
->count() â€“ count elements
->anyMatch(Predicate) â€“ true if any element matches
->allMatch(Predicate) â€“ true if all elements match
->noneMatch(Predicate) â€“ true if no elements match
->findFirst() â€“ first element (Optional)
->findAny() â€“ any element (especially in parallel streams)




