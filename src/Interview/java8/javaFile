ðŸ”¹ Stream API in Java
Introduced in Java 8, the Stream API is used to process collections of objects (like List, Set, etc.) in a functional style.
It allows operations like filtering, mapping, sorting, and reducing data with less code.
Streams donâ€™t store data; they work on collections and produce a result.
They support parallel processing, making them faster for large datasets.

-->Stream API in Java 8 is used to process collections in a functional style.
It provides methods like filter, map, sorted, forEach, reduce, and collect.
It helps in writing clean, concise, and efficient code, and supports both sequential and parallel processing.

ðŸ”¹ Important Stream Methods
filter(Predicate) â†’ Selects elements based on condition.
list.stream().filter(n -> n % 2 == 0).toList(); // Even numbers

map(Function) â†’ Transforms elements.
list.stream().map(n -> n * 2).toList(); // Double each number

sorted() â†’ Sorts elements.
list.stream().sorted().toList();

distinct() â†’ Removes duplicates.
limit(n) / skip(n) â†’ Limit or skip elements.

forEach(Consumer) â†’ Iterate and perform action.

list.stream().forEach(System.out::println);

collect(Collectors.toList()) â†’ Collects stream into a list.

reduce() â†’ Combines elements into a single result.

int sum = list.stream().reduce(0, Integer::sum);

anyMatch(), allMatch(), noneMatch() â†’ Check conditions.

count() â†’ Counts elements.

ðŸ”¹ Uses of Stream API
Reduces boilerplate code (no need for explicit loops).
Makes code more readable and declarative.
Useful for filtering, transformation, and aggregation of data.
Supports parallel streams for performance on large data.
Used heavily in modern Java applications, Spring, and Microservices for data processing.

ðŸ”¹@Functional interface annotation and what is functional interface
ðŸ”¹ Functional Interface
A Functional Interface in Java is an interface that has exactly one abstract method.
It can have multiple default and static methods, but only one abstract method.
These interfaces are mainly used for Lambda Expressions and Method References.
Example: Runnable, Callable, Comparator, Consumer.
Real-time use: Instead of writing anonymous classes, we can use lambdas with functional interfaces.

@FunctionalInterface
interface MyFunctional {
    void sayHello();  // Only one abstract method
}

ðŸ”¹ @FunctionalInterface Annotation
It is used to mark an interface as a functional interface.
If you accidentally add more than one abstract method, the compiler will throw an error.
It improves readability and ensures correctness.

Example:

@FunctionalInterface
interface Calculator {
    int add(int a, int b);
}
