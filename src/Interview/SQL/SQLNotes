INDEX in SQL:-
-----------------
An Index in SQL is like an index in a book â€“ it helps the database find the rows faster without scanning the entire table.
It was introduced to improve the performance of SELECT queries (especially with large data).
Indexes store a reference to table rows in a sorted order, making searches, filtering (WHERE), and joins faster.
However, they take extra storage and can slow down INSERT, UPDATE, and DELETE because the index must also be updated.
We should use an index on columns that are frequently used in WHERE, JOIN, or ORDER BY clauses.
Common types are single-column index, composite index, unique index, and clustered index.

Syntax:-
---------------
-- Create index
CREATE INDEX idx_column_name
ON table_name (column_name);

-- Composite index (multiple columns)
CREATE INDEX idx_col1_col2
ON table_name (col1, col2);

Real-World Scenario:
Imagine a Banking System with a transactions table containing millions of records.
Customers frequently search by account_number. Without an index, the database scans all rows (slow).
By creating an index on account_number, queries like:

ex:-
CREATE INDEX idx_account_date
ON transactions(account_number, transaction_date);

SELECT account_number, balance
FROM transactions
WHERE account_number = '123456789';
********************************************************************************

Function in SQL
-----------------------
A Function is a reusable SQL object that always returns a value (scalar or table).
It is mainly used for calculations or transformations inside queries.
Functions cannot perform INSERT/UPDATE/DELETE (read-only).
They must return exactly one result.
Often used in SELECT, WHERE, or JOIN clauses.
Example: calculating age from date of birth.

commonly used built-in SQL functions:-
1. String Functions
UPPER() â†’ Converts text to uppercase.
LOWER() â†’ Converts text to lowercase.
LEN() / LENGTH() â†’ Finds string length.
SUBSTRING() â†’ Extracts part of a string.
TRIM() / LTRIM() / RTRIM() â†’ Removes spaces.
CONCAT() â†’ Joins strings.

2. Numeric Functions
ABS() â†’ Absolute value.
ROUND() â†’ Rounds a number.
CEILING() / FLOOR() â†’ Rounds up or down.
POWER(x, y) â†’ x raised to the power y.
SQRT() â†’ Square root.

3. Date & Time Functions

GETDATE() (SQL Server) / NOW() (MySQL, PostgreSQL) â†’ Current date & time.
CURDATE() â†’ Current date.
DATEDIFF() â†’ Difference between two dates.
DATEADD() â†’ Add interval to a date.
EXTRACT(YEAR FROM date) â†’ Extract part of a date.

4. Aggregate Functions
COUNT() â†’ Number of rows.
SUM() â†’ Total sum of values.
AVG() â†’ Average of values.
MIN() â†’ Minimum value.
MAX() â†’ Maximum value.
****************************************************************

Stored Procedure in SQL
-------------------------
A Stored Procedure is a set of SQL statements stored in the database.
It can perform multiple tasks like SELECT, INSERT, UPDATE, DELETE.
Procedures may return data or nothing (flexible).
They support loops, conditions, and transactions.
Often used for business logic, reporting, or bulk operations.
Example: processing payroll or fetching employee details.

âš¡ Easy memory trick:
Stored Procedures are used for CRUD operations (Create, Read, Update, Delete).

******************************************************************************

JOINS in SQL:-
--------------
A Join in SQL is used to combine the data from two or more tables using a related column (like customer_id).
It helps us to get connected information that is stored in different tables.
Most of the time, this relationship is through a primary keyâ€“foreign key link.
There are different types of joins: INNER, LEFT, RIGHT, FULL, CROSS, and SELF.
Joins help us avoid duplicate storage by keeping data in separate tables but still allowing us to query them together.
Real-world example: Join customers and orders to see each customer with their order details.

Lets take below 2 tables for practice all joins.
customers:-
customer_id	     name
1	             Hari
2	             John
3	             Ravi

orders:-
order_id	customer_id	 product
101         	1	      Laptop
102          	2	      Phone
103	            2	      Tablet

1. INNER JOIN
ðŸ‘‰ it will Returns only customers who have orders in order table. (matching rows).
In order table we have cust_id's 1 & 2 only , That means 3 rd customer is not ordered yet.
So ,it will return only Hari & John details.

Query:
SELECT c.customer_id, c.name, o.order_id, o.product
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id;

Result: Hari & John (because Ravi has no orders).

2. LEFT JOIN
ðŸ‘‰ It will take customers table as primary and Returns all customers + their orders if present in Order table.
It will return NULL if no orders present.

Query:
SELECT c.customer_id, c.name, o.order_id, o.product
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id;

Result: Hari, John with orders, and Ravi with NULL (because no order).

3. RIGHT JOIN
ðŸ‘‰ it will take Orders table as primary and it will Returns all orders + their customers if present .
it will return NULL if no customer present for the orders .

Query:
SELECT c.customer_id, c.name, o.order_id, o.product
FROM customers c
RIGHT JOIN orders o ON c.customer_id = o.customer_id;

Result: Hari & John with their orders. it will not return Ravi, Because no order present for Ravi in order table.
That' why order table will not know Ravi cust Id.

4. FULL OUTER JOIN
ðŸ‘‰ It will take both tables as primary and Returns all customers and all orders, matching where possible, NULL where not.

Query:
SELECT c.customer_id, c.name, o.order_id, o.product
FROM customers c
FULL OUTER JOIN orders o ON c.customer_id = o.customer_id;

Result: Hari & John with orders + Ravi with NULL + any order without a customer.

5. CROSS JOIN
ðŸ‘‰ Returns all possible combinations from both tables.

Query:
SELECT c.name, o.product
FROM customers c
CROSS JOIN orders o;

Result: Every customer with every product (Hariâ€“Laptop, Hariâ€“Phone, Hariâ€“Tablet, Johnâ€“Laptop â€¦ etc.).

**********************************************************************************************************

What is Normalization?
------------------------
â€œNormalization is the process of structuring a database into multiple related tables to reduce redundancy and ensure data integrity.
It is done using Normal Forms like 1NF (remove repeating groups), 2NF (remove partial dependency), and 3NF (remove transitive dependency).
For example, Instead of storing customer details in every order row, we keep a Customer table and link it to an Orders table using a foreign key.
This avoids duplication and keeps data consistent.â€

Real-World Scenario
-----------------------
Imagine an e-commerce system:
If we store order details like Customer Name, Address, Product, Quantity in one single table, customer details will repeat for every order.
If the customer changes address, we must update it in many rows â†’ prone to errors.
With normalization:
Customer table stores customer details once.
Orders table stores order details with a reference to the customer.
ðŸ‘‰ This reduces redundancy and keeps data consistent.

Types of Normal Forms:-
-----------------------
Step 1: Unnormalized Data (UNF): If we take customer & Orders table. In this form every data like cust id, cust name, prod id, prod name are in same table.

CREATE TABLE Orders_UNF (
    order_id INT,
    customer_name VARCHAR(50),
    customer_address VARCHAR(100),
    products VARCHAR(100) -- multiple products in one column
);
Sample Data (UNF):

order_id	customer_name	customer_address	products
101	            Hari	        Bangalore	   Laptop, Phone
102	            John	          Delhi	         Tablet
103	            Hari	        Bangalore	    Laptop

ðŸ‘‰ Problems:
In above table we see Duplicate customer info (Hari appears twice).And also
Products stored in a single column (not atomic).

Step 2: First Normal Form (1NF): Here we Remove repeating groups and store atomic values.

CREATE TABLE Orders_1NF (
    order_id INT,
    customer_name VARCHAR(50),
    customer_address VARCHAR(100),
    product VARCHAR(50)
);

Sample Data (1NF):
order_id	customer_name	customer_address	product
101	           Hari	            Bangalore	    Laptop
101	           Hari	            Bangalore	     Phone
102	           John	             Delhi	         Tablet
103	           Hari	            Bangalore	     Laptop

ðŸ‘‰ Problem reduced: Products are now atomic. But still customer info repeats.

Step 3: Second Normal Form (2NF):Remove partial dependency â†’ we can create Separate tables for Customers and Orders.

CREATE TABLE Customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(50),
    address VARCHAR(100)
);

CREATE TABLE Orders_2NF (
    order_id INT PRIMARY KEY,
    customer_id INT,
    product VARCHAR(50),
    FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);

Customers Table:
customer_id 	name	address
1	            Hari	Bangalore
2	            John	Delhi

Orders Table:
order_id	 customer_id	product
101	            1	        Laptop
101	            1	        Phone
102	            2	        Tablet
103	            1	        Laptop

ðŸ‘‰ Customer info is stored only once.

Step 4: Third Normal Form (3NF):
Remove transitive dependency. Example: if we store City and Pincode in Customers, city depends on Pincode, not Customer directly.

CREATE TABLE Cities (
    pincode INT PRIMARY KEY,
    city VARCHAR(50)
);

ALTER TABLE Customers ADD pincode INT;
ALTER TABLE Customers ADD FOREIGN KEY (pincode) REFERENCES Cities(pincode);

Cities Table:
pincode	city
560001	Bangalore
110001	Delhi

Customers Table (Final 3NF):
customer_id	name	pincode
1	        Hari	560001
2	        John	110001

**What is Denormalization?
---------------------------
â€œNormalization removes redundancy by splitting data into related tables, while denormalization combines tables to speed up queries at the cost of some redundancy.
For example, in an e-commerce system, normalized tables keep Customers and Orders separate.
But in a reporting system, we may denormalize and keep customer and order info in one table so queries run faster without joins.â€


When to Use Normalization
--------------------------
->When data consistency and accuracy are most important.
->If your system does a lot of inserts, updates, and deletes (OLTP systems like banking apps, e-commerce apps).
->To avoid redundancy (no duplicate customer info stored multiple times).
->When storage space is limited.

Example: In a banking system, customer details are stored in a separate table â†’ any update (like address change) is reflected everywhere.

ðŸ”¹ When to Use Denormalization
------------------------------
->When performance of SELECT queries is more important than avoiding redundancy.
->If your system is used for reporting, analytics, dashboards (OLAP systems).
->To reduce the number of joins in frequently used queries.
->When you can afford extra storage and some redundancy.
Example: In a sales reporting system, customer + orders + products might be combined into one big table to get quick reports.

*****************************************************************************************************************************
ðŸ”¹ What is Ranking in SQL?
-----------------------------
Ranking in SQL means assigning a position (rank/number) to each row based on some ordering criteria (like salary, marks, sales).
It is done using window functions such as RANK(), DENSE_RANK(), and ROW_NUMBER().
Ranking is helpful when we want to find top performers, highest salaries, best sellers, leaderboards, etc.
For example, if we rank employees by salary, the one with the highest salary gets rank 1, the next gets rank 2, and so on.
If two rows have the same value (tie), the way ranks are assigned depends on which ranking function is used.

Employee Table (sample data)
emp_id	name	dept	salary
1	    Hari	IT	    70000
2	    John	HR	    60000
3	    Ravi	IT	    60000
4	    Meena	Finance	 50000
5	    Sita	IT	    40000

ðŸ”¹ What is ROW_NUMBER() in SQL?
ROW_NUMBER() assigns a unique sequential number to each row, based on ordering.
Unlike RANK() and DENSE_RANK(), it doesnâ€™t care about duplicatesâ€”every row gets a different number.
For example, when ranking employees by salary, even if two employees have the same salary, they get different row numbers.
It is widely used in pagination, finding duplicate rows, and selecting the top N records.

Query: Assign row numbers based on salary (highest to lowest)
SELECT name, dept, salary,
       ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num
FROM employees;

Result:
name	dept	salary	row_num
Hari	IT	    70000	1
John	HR	    60000	2
Ravi	IT	    60000	3
Meena	Finance	50000	4
Sita	IT	    40000	5

ðŸ‘‰ Notice: Even though John & Ravi have the same salary, they still got different row numbers (2 and 3).
-------------
ðŸ”¹ What is RANK() in SQL?
RANK():- in SQL is a window function that assigns a rank to each row based on an ORDER BY clause.
If two or more rows have the same value, they get the same rank, but the next rank is skipped (creating gaps).
The syntax is:

RANK() OVER (PARTITION BY colX ORDER BY colY DESC)

It is commonly used in ranking scenarios like top salaries, student marks, or sales reports.
For example, if two employees share 2nd place in salary ranking, the next employee will be ranked 4th.

sample query:-
--------------
Rank employees by salary (highest to lowest)
SELECT name, dept, salary,
       RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

Result:
name	dept	salary	salary_rank
Hari	IT	     70000	1
John	HR	    60000	2
Ravi	IT	     60000	2
Meena	Finance	50000	4
Sita	IT	    40000	5

ðŸ‘‰ Notice: John & Ravi have the same salary â†’ both get rank 2, and the next rank becomes 4 (gap created).

ðŸ”¹ What is DENSE_RANK() in SQL?
DENSE_RANK() assigns ranks to rows based on ordering but does not skip ranks when there are ties.
If two employees have the same salary, they both get the same rank, and the next rank continues normally.
For example, if two employees share 2nd place, the next one gets rank 3 (not 4).
It is commonly used in salary analysis, student marks, or leaderboard rankings where continuous ranks are preferred.

Query: Rank employees by salary (highest to lowest)
SELECT name, dept, salary,
       DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

Result:
name	dept	salary	salary_rank
Hari	IT	    70000	1
John	HR	    60000	2
Ravi	IT	    60000	2
Meena	Finance	50000	3
Sita	IT	    40000	4





