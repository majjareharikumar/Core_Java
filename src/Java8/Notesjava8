Q1. What are the main features introduced in Java 8?
Answer:
Java 8 introduced powerful features aimed at writing cleaner, more functional code:
New Features in Java 8
‚Ä¢ Interface changes (default & static methods)
‚Ä¢ Lambda Expressions
‚Ä¢ Functional Interfaces
o Consumer
o Supplier
o Predicate
o Function
‚Ä¢ Stream API
‚Ä¢ Date & Time API changes
‚Ä¢ Optional class
‚Ä¢ SplIterator
‚Ä¢ Stringjoiner
‚Ä¢ Method References
‚Ä¢ Constructor References
‚Ä¢ Collections Framework changes
These features help improve performance, parallelism, and code readability.

Q2. What is a Lambda Expression?
Answer:
A Lambda Expression is a short block of code that takes in parameters and returns a value, used to implement functional interfaces.
It allows us to write short and clear code without creating a separate method or class.
Syntax:
(parameter) -> { body }
Example:
List<Integer> list = Arrays.asList(1, 2, 3);
list.forEach(n -> System.out.println(n));

Q3. What is a Functional Interface?
Answer:
A functional interface has only one abstract method.
It can have multiple default or static methods.
They are the basis for lambda expressions.
Annotated with @FunctionalInterface to indicate intention.

Example:
@FunctionalInterface
interface MyFunc { void sayHello(); }

Q4. What is the Stream API?
Answer:
Stream API in Java 8 is used to process collections of data in a functional style.
It supports operations like filtering, mapping, and reducing data using pipelines.
Streams don‚Äôt store data but operate on it, and they support both sequential and parallel processing.
Intermediate operations like map() and filter() return another stream, while terminal operations like collect() or forEach() produce the result.
This makes the code more concise, readable, and efficient compared to traditional loops.
Example:
List<String> names = list.stream().filter(n -> n.startsWith("A")).collect(Collectors.toList());

Q5.What is map() and flatMap()? in java 8 & What is the difference between map() and flatMap()?
map() is a method in Java 8 Stream API used to transform each element of a stream by applying a function.
It returns a new stream with the same number of elements, each transformed individually.

üëâ Think of it as: one input ‚Üí one output

Example:
List<String> names = List.of("john", "smith");
List<String> upper = names.stream()
                          .map(String::toUpperCase)
                          .collect(Collectors.toList());
// Output: ["JOHN", "SMITH"]

üîπ What is flatMap() in Java 8?
flatMap() is used to flatten and transform a stream of collections (like List of Lists).
It combines multiple streams into one single stream after applying the transformation.

üëâ Think of it as: one input ‚Üí many outputs (flattened into one stream)

Example:
List<List<String>> namesList = List.of(
    List.of("john", "doe"),
    List.of("smith", "jane")
);

List<String> flatList = namesList.stream()
                                 .flatMap(List::stream)
                                 .collect(Collectors.toList());
// Output: ["john", "doe", "smith", "jane"]

üî∏ Difference Between map() and flatMap()
Feature	             map()	              flatMap()
Transformation	One-to-one	        One-to-many (then flattened)
Output Type	   Stream of values	    Flattened single stream of all values
Used With	     Simple objects	    Nested structures like List of Lists
Flattening	  ‚ùå Does not flatten	‚úÖ Flattens the stream

Q6. What is the Optional class in Java 8?
Optional is a container class introduced in Java 8 to handle null values safely.
It helps avoid NullPointerException by forcing developers to explicitly deal with missing values.
You can create an Optional using Optional.of(), Optional.ofNullable(), or Optional.empty().
It provides useful methods like isPresent(), ifPresent(), orElse(), orElseGet(), and orElseThrow().

‚úÖ Example:
Optional<String> name = Optional.ofNullable(getName());
name.ifPresent(n -> System.out.println(n)); // prints if value is present
This avoids null checks manually and promotes safer, cleaner code.

üîπ Q7. What are default and static methods in interfaces?
n Java 8, interfaces were enhanced with default and static methods.
A default method is a method with a body inside an interface, declared with the default keyword.
It allows us to add new methods to interfaces without breaking existing classes.
Static methods, on the other hand, belong to the interface itself and must be called using the interface name.
Default methods can be overridden by implementing classes, but static methods cannot.
This feature was introduced to support functional programming and backward compatibility.

The purpose of adding static methods in interfaces was to provide utility or helper methods directly within the interface, instead of keeping them in external utility classes.
This keeps related behavior encapsulated inside the interface and makes the API design cleaner.
Static methods also ensure backward compatibility because they don‚Äôt affect existing implementations and cannot be overridden, ensuring consistent behavior.
They are useful for operations that don‚Äôt depend on instance data but are common to all implementations.

‚úÖ Example:
interface MyInt {
  default void show() { System.out.println("Default method"); }
  static void print() { System.out.println("Static method"); }
}
Default methods can be overridden; static methods can‚Äôt.

üîπ Q8. What is method reference in Java 8?
Method reference in Java 8 is a shorthand syntax for calling methods using the :: (double colon) operator.
It is an alternative to lambda expressions when the lambda only calls an existing method.
There are four types: reference to a static method, reference to an instance method, reference to an instance method of an arbitrary object, and reference to a constructor.
Method references make code cleaner, more readable, and avoid unnecessary boilerplate.

‚úÖ Example:
List<String> list = Arrays.asList("A", "B");
list.forEach(System.out::println); // same as list.forEach(s -> System.out.println(s));

üîπ Q9. What is the difference between findFirst() and findAny()?
Both methods are terminal operations in Stream API and return an Optional.
findFirst() returns the first element of the stream ‚Äî deterministic and order-preserving.
findAny() may return any element, and is faster for parallel streams.
Use findFirst() when order matters, and findAny() when performance is preferred over order.

‚úÖ Example:
list.stream().findFirst();         // Always returns first
list.parallelStream().findAny();   // May return any element

üîπ Q10. How does Java 8 improve Date and Time handling?
In Java 8, a new Date and Time API (java.time) was introduced to overcome issues with the old Date and Calendar classes.
The API is immutable, thread-safe, and more user-friendly.
Common classes include LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Period, Duration, and Instant.
 Frequently used methods are now(), of(), plusDays(), minusMonths(), between(), toHours(), and isAfter().
  This API makes working with dates and times much simpler and less error-prone.

‚úÖ Example:
LocalDate today = LocalDate.now();
System.out.println(today.plusDays(5)); // Adds 5 days to current date

Q11. What is the difference between orElse() and orElseGet() in Optional?
Both methods provide a fallback value if the Optional is empty:
orElse(value) always evaluates the value, even if it's not used.
orElseGet(Supplier) executes only if needed, so it's more efficient for expensive operations.
Use orElse() for static or cheap values, and orElseGet() for dynamic or costly values.

‚úÖ Example:
String name = Optional.ofNullable(null)
                      .orElseGet(() -> getDefault()); // getDefault() called only if null

üîπ Q12. What is a predicate in Java 8?
A Predicate is a functional interface from java.util.function package.
It represents a boolean-valued function (i.e., it tests a condition).
It‚Äôs often used with filter() in streams and supports and(), or(), negate() for chaining logic.
It has the method:
boolean test(T t);
‚úÖ Example:
Predicate<String> isLong = s -> s.length() > 5;
System.out.println(isLong.test("HelloWorld")); // true

üîπ Q13. What are some common functional interfaces in Java 8?
Java 8 provides many built-in functional interfaces in the java.util.function package:
Predicate<T> ‚Äì returns boolean
Function<T, R> ‚Äì converts T to R
Consumer<T> ‚Äì accepts T, returns nothing
Supplier<T> ‚Äì provides a value of type T
BiFunction<T,U,R>, BiPredicate<T,U>, etc.
These are heavily used in lambda expressions and Stream API operations.

‚úÖ Example:
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello");

üîπ Q14. What is the reduce() method in Stream API?
reduce() is a terminal operation in Stream API.
It combines stream elements into a single value.
Uses a binary operation like sum, max, or concatenation.
Can return Optional if identity is not provided.
Commonly used for aggregation logic.
Works efficiently with parallel streams.
Promotes functional programming style.
‚úÖ Example:
int sum = Arrays.asList(1, 2, 3).stream().reduce(0, (a, b) -> a + b); // sum = 6
If no identity is given, it returns an Optional.

üîπ Q15. What are the advantages of using Stream API?
Stream API enables functional-style operations on collections with better readability and less code.
It supports lazy evaluation, making it memory and performance efficient.
It simplifies data transformation using map, filter, and reduce.
It also supports easy parallel processing using .parallelStream().
‚úÖ Example:
List<String> result = names.stream().filter(n -> n.startsWith("A")).collect(Collectors.toList());

Q16. What is the use of peek() in Stream API?
peek() is an intermediate operation in Stream API.
It is mainly used for debugging purposes.
It allows observing elements as they flow through the stream.
It does not change the stream elements.
It executes only when a terminal operation is called.
Not recommended for business logic.
Works lazily like other stream operations.

Example:-
List<Integer> numbers = List.of(1, 2, 3, 4);
numbers.stream()
       .peek(n -> System.out.println("Before filter: " + n))
       .filter(n -> n % 2 == 0)
       .peek(n -> System.out.println("After filter: " + n))
       .forEach(System.out::println);
OutPut:-
Before filter: 1
Before filter: 2
After filter: 2
Before filter: 3
Before filter: 4
After filter: 4


üîπ Q17. What is the difference between map() and flatMap() in Java 8?
map() transforms each element into another object (one-to-one mapping).
flatMap() is used when each element can be transformed into multiple elements or streams (one-to-many).
flatMap() flattens nested structures like List<List<T>> into a single List<T>.
Use flatMap() when dealing with nested collections or Optional streams.

‚úÖ Example:
List<String> words = Arrays.asList("a b", "c d");
words.stream()
     .flatMap(w -> Arrays.stream(w.split(" ")))
     .forEach(System.out::println);  // a, b, c, d

üîπ Q18. What is a functional interface?
A functional interface is an interface with exactly one abstract method.
It can have multiple default or static methods, but only one abstract method.
Functional interfaces are used as the target types for lambda expressions and method references.
Common examples include Runnable, Callable, Predicate, and Function.

‚úÖ Example:
@FunctionalInterface
interface MyFunc {
    void show();
}

üîπ Q19. What is the difference between Collection and Stream API?
Collection stores data in memory and represents a data structure like List or Set.
Stream is a pipeline to process data from a Collection in a functional style.
Collection is eager (data is fetched/stored), whereas Stream is lazy (data is processed when needed).
Streams don‚Äôt store elements; they transform and filter them on-the-fly.

‚úÖ Example:
List<String> list = Arrays.asList("A", "B");
list.stream().map(String::toLowerCase).forEach(System.out::println);

üîπ Q20. How does Collectors.toList(), toSet(), and joining() work?
These are collector utilities used to collect stream results into collections or strings:
toList() collects elements into a List
toSet() collects elements into a Set
joining(delimiter) combines elements into a single String with a delimiter

‚úÖ Example:
List<String> names = list.stream().collect(Collectors.toList());
String joined = list.stream().collect(Collectors.joining(", "));

Q21. What is the Stream.of() method?
Stream.of() is a static method used to create a sequential stream from given values or an array.
It‚Äôs useful for quick testing or creating a small data pipeline without needing a collection.
The returned stream can be processed using standard Stream operations like map(), filter(), etc.
It‚Äôs part of java.util.stream.Stream.

‚úÖ Example:
Stream.of("Java", "Python", "C++")
      .filter(lang -> lang.contains("a"))
      .forEach(System.out::println);

üîπ Q22. What is IntStream, LongStream, and DoubleStream in Java 8?
Java 8 provides primitive specializations of Stream API for better performance:
IntStream, LongStream, and DoubleStream deal with int, long, and double primitives.
They avoid autoboxing overhead and support methods like sum(), average(), range(), etc.
These are in java.util.stream package.

‚úÖ Example:
IntStream.range(1, 5).forEach(System.out::print); // prints 1234

üîπ Q23. What is the purpose of the limit() and skip() methods in Stream?
limit(n) is used to restrict the number of elements in the stream to the first n.
skip(n) is used to ignore the first n elements of the stream.
Both are intermediate operations and are useful for pagination, batching, or slicing data.

‚úÖ Example:
list.stream()
    .skip(2)
    .limit(3)
    .forEach(System.out::println);  // skips first 2, prints next 3


üîπ Q24. What is the difference between Stream.iterate() and Stream.generate()?
Stream.iterate(seed, UnaryOperator) creates an infinite stream by applying a function repeatedly.
Stream.generate(Supplier) creates an infinite stream of random or constant values.
Both need to be limited using limit() to prevent infinite processing.

‚úÖ Example:

Stream.iterate(1, n -> n + 2).limit(5).forEach(System.out::println);  // 1 3 5 7 9
Stream.generate(Math::random).limit(3).forEach(System.out::println); // 3 random numbers

üîπ Q25. What is Collectors.groupingBy() in Java 8?
The Collectors.groupingBy() method in Java 8 is used to group stream elements based on a classification function, similar to SQL GROUP BY.
By default, it returns a Map<K, List<T>>, where keys are the grouping criteria and values are lists of elements.
We can also use downstream collectors to count, sum, or average values within each group.
For example, grouping employees by department, counting them, or finding average salary per department.
It is one of the most powerful collectors in the Stream API for data aggregation.

‚úÖ Example:
Map<String, List<String>> grouped = names.stream()
    .collect(Collectors.groupingBy(name -> name.substring(0, 1)));

Q26. What is Collectors.partitioningBy() in Java 8?
partitioningBy() is a special type of grouping that splits data into two groups: true and false.
It takes a Predicate and returns a Map<Boolean, List<T>>.
Useful when you want to divide elements into two categories based on a condition.

‚úÖ Example:
Map<Boolean, List<Integer>> partitioned =
    numbers.stream().collect(Collectors.partitioningBy(n -> n % 2 == 0));
System.out.println(partitioned.get(true));  // Even numbers
System.out.println(partitioned.get(false)); // Odd numbers

üîπ Q27. What is the difference between forEach() and forEachOrdered()?
forEach() processes elements in any order, especially when used with parallelStream().
forEachOrdered() maintains the encounter order of elements, even in parallel streams.
Use forEachOrdered() when output order is important.

‚úÖ Example:
list.parallelStream().forEach(System.out::print);        // may be unordered
list.parallelStream().forEachOrdered(System.out::print); // ordered output


üîπ Q28. What is the use of Optional.map() and flatMap()?
map() is used to transform the value inside Optional if present.
flatMap() is used when the transformation also returns an Optional, avoiding nested Optionals.
They make chaining Optional operations clean and null-safe.

‚úÖ Example:
Optional<String> name = Optional.of("Hari");
Optional<Integer> length = name.map(String::length); // Optional[4]

üîπ Q29. Can we create an infinite stream in Java 8?
Yes, Java 8 supports infinite streams using Stream.generate() or Stream.iterate().
These streams must be bounded with limit(), otherwise they can lead to infinite processing.
Useful for generating random values, sequences, or simulation data.

‚úÖ Example:
Stream.generate(() -> "Hello").limit(3).forEach(System.out::println); // prints Hello 3 times

üîπ Q30. What is the use of distinct() method in Stream API?
The distinct() method removes duplicate elements from a stream.
It uses equals() to compare elements, so custom objects should override equals() and hashCode().
It‚Äôs an intermediate operation and returns a stream with unique elements.

‚úÖ Example:
Stream.of(1, 2, 2, 3, 3).distinct().forEach(System.out::println); // 1 2 3

Q31. What is the takeWhile() method in Java 9? (For awareness in Java 8 context)
Even though takeWhile() was added in Java 9, it‚Äôs often asked to check Java 8 knowledge boundaries.
takeWhile() processes elements until the condition fails and then stops.
This avoids full iteration and helps improve performance in ordered streams.
Not available in Java 8, but you can implement similar logic manually using filter() and flags.

‚úÖ Example (Java 9+):
Stream.of(1, 2, 3, 4, 5, 0).takeWhile(n -> n < 4).forEach(System.out::println); // 1 2 3

üîπ Q32. How do you sort a collection using Stream API?
You can sort a stream using sorted() method.
It can work with natural order or custom Comparator.
sorted() returns a new sorted stream without changing the original list.

‚úÖ Example:
list.stream()
    .sorted() // natural order
    .forEach(System.out::println);

list.stream()
    .sorted(Comparator.reverseOrder()) // custom order
    .forEach(System.out::println);


üîπ Q33. Can we perform parallel processing in Java 8 Streams?
Yes, Java 8 introduced parallelStream() to support parallelism using multiple threads.
It splits data and processes chunks in parallel, improving performance on large data.
Use it carefully when order doesn‚Äôt matter or with thread-safe operations.
Avoid shared mutable state to prevent bugs.

‚úÖ Example:
list.parallelStream().forEach(System.out::println);

üîπ Q34. What is the use of anyMatch(), allMatch(), and noneMatch()?
These methods are used to check conditions on elements in a stream:
anyMatch() returns true if at least one element matches the condition.
allMatch() returns true if all elements match the condition.
noneMatch() returns true if no elements match the condition.

‚úÖ Example:
boolean hasEven = list.stream().anyMatch(n -> n % 2 == 0);

üîπ Q35. What is Collectors.toMap() in Java 8?
toMap() is used to collect stream elements into a Map.
You need to provide keyMapper and valueMapper functions.
In case of duplicate keys, it throws an exception unless you handle with a merge function.

‚úÖ Example:
Map<String, Integer> map =
    list.stream().collect(Collectors.toMap(
        s -> s,             // key
        s -> s.length()     // value
    ));

Q36. What is Collectors.counting() in Java 8?
Collectors.counting() is a collector used to count the number of elements in a stream.
It acts as a terminal operation that returns a Long value.
This is especially useful when combined with groupingBy() for grouped counts.

‚úÖ Example:
long count = list.stream().collect(Collectors.counting());

Map<String, Long> countByName = list.stream()
    .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));


üîπ Q37. How do you convert a list to a map using Java 8 Streams?
Use Collectors.toMap() by providing a key extractor and value extractor function.
Make sure keys are unique, or handle duplicates using a merge function.
This is a common task in data transformation using streams.

‚úÖ Example:
Map<Integer, String> map = employees.stream()
    .collect(Collectors.toMap(
        emp -> emp.getId(),
        emp -> emp.getName()
    ));

üîπ Q38. How do you remove null values from a list using Streams?
Use filter() method to exclude null values while processing the stream.
This is a clean and efficient way to avoid NullPointerException.
Java 8‚Äôs functional style makes this operation concise and readable.

‚úÖ Example:
List<String> result = list.stream()
    .filter(Objects::nonNull)
    .collect(Collectors.toList());


üîπ Q39. How can you find the max or min value in a stream?
You can use max() and min() with a Comparator to get the largest or smallest element.
These methods return an Optional to safely handle empty streams.
Useful in analytics, ranking, and data comparison.

‚úÖ Example:
Optional<Integer> max = list.stream().max(Integer::compareTo);
Optional<Integer> min = list.stream().min(Integer::compareTo);

üîπ Q40. How can you convert a stream to an array?
Use the toArray() terminal operation.
You can also provide a generator function like String[]::new to get a typed array.
This is useful when you need array-based processing after stream operations.

‚úÖ Example:
String[] names = list.stream().toArray(String[]::new);

Q41. How can you filter a Map using Java 8?
To filter a Map, convert it into a Stream using entrySet().stream() and apply filter().
Then collect the result back into a Map using Collectors.toMap().
This is useful for selecting specific entries based on keys or values.

‚úÖ Example:
Map<String, Integer> filtered = map.entrySet().stream()
    .filter(e -> e.getValue() > 50)
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));


üîπ Q42. How can you merge two lists in Java 8?
Use Stream.concat() to combine two streams and collect the result into a list.
This is a clean way to merge collections functionally.
You can also apply distinct() if you want to remove duplicates.

‚úÖ Example:
List<String> merged = Stream.concat(list1.stream(), list2.stream())
    .collect(Collectors.toList());

üîπ Q43. What is the use of peek() in Java 8 Stream?
peek() is an intermediate operation used for debugging or logging stream elements.
It doesn‚Äôt modify the stream but allows you to look at elements as they flow through the pipeline.
Avoid using peek() for modifying data ‚Äî it should only be used for inspection.

‚úÖ Example:
list.stream()
    .peek(e -> System.out.println("Processing: " + e))
    .filter(e -> e.startsWith("J"))
    .collect(Collectors.toList());

üîπ Q44. What is the difference between map() and flatMap()?
map() transforms each element and wraps it, returning a Stream<Stream<T>> in nested cases.
flatMap() flattens nested structures into a single stream, returning Stream<T>.
Use flatMap() when you deal with List<List<T>>, Optional<Optional<T>>, etc.

‚úÖ Example:
list.stream()
    .map(String::toUpperCase); // Stream<String>

nestedList.stream()
    .flatMap(List::stream);    // Stream<String> from Stream<List<String>>

üîπ Q45. What are terminal and intermediate operations in streams?
Intermediate operations (like map(), filter(), sorted()) return a new stream. They are lazy and only executed when a terminal operation is called.
Terminal operations (like collect(), forEach(), count()) trigger stream processing and return a result or side effect.
Without a terminal operation, intermediate steps are never executed.

‚úÖ Example:
long count = list.stream()
    .filter(e -> e.length() > 3) // intermediate
    .count();                    // terminal

Q46. How can you convert a list of objects into a map using Java 8?
You can use Collectors.toMap() to convert a list of objects into a Map.
Provide key and value mapping logic, often using object fields.
Be sure to handle duplicate keys with a merge function, if needed.

‚úÖ Example:
Map<Integer, String> empMap = employeeList.stream()
    .collect(Collectors.toMap(
        Employee::getId,
        Employee::getName
    ));

üîπ Q47. What is the difference between Stream.of() and Arrays.stream()?
Stream.of() can take any number of individual values or an array and return a stream.
Arrays.stream() is specifically for arrays and can avoid boxing in some cases.
Both create streams, but Arrays.stream() is preferred for primitive arrays.

‚úÖ Example:
Stream<Integer> s1 = Stream.of(1, 2, 3);
Stream<Integer> s2 = Arrays.stream(new Integer[]{1, 2, 3});

üîπ Q48. How to perform grouping in Java 8 using Stream API?
Use Collectors.groupingBy() to group elements by a specific key.
It returns a Map where the key is the grouping field, and the value is a list of grouped items.
Useful in data classification and aggregation.

‚úÖ Example:
Map<String, List<Employee>> groupedByDept = employeeList.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

üîπ Q49. What is the use of Collectors.joining() in Java 8?
Collectors.joining() is used to concatenate strings from a stream.
You can also add a delimiter, prefix, and suffix to the joined string.
Commonly used for formatting or combining output strings.

‚úÖ Example:
String names = list.stream()
    .collect(Collectors.joining(", ", "[", "]")); // e.g., [Ram, Hari, John]

üîπ Q50. How does lazy evaluation work in Java 8 Streams?
Java 8 Streams use lazy evaluation, meaning intermediate operations are not executed until a terminal operation is called.
This allows optimization and avoids unnecessary processing.
For example, a filter() won‚Äôt run unless followed by collect(), count(), or forEach().

‚úÖ Example:
Stream<String> stream = list.stream().filter(s -> {
    System.out.println(s); // won‚Äôt print unless terminal op runs
    return s.startsWith("A");
});
long count = stream.count(); // triggers evaluation

Q53. How can you handle checked exceptions in lambda expressions?
Lambdas in Java can‚Äôt throw checked exceptions directly unless caught or wrapped.
You can use try-catch inside the lambda or write a custom functional interface.
Java 8 doesn‚Äôt support throwing checked exceptions from Function, Consumer, etc.

‚úÖ Example:
list.forEach(s -> {
    try {
        someMethodThatThrowsException(s);
    } catch (IOException e) {
        e.printStackTrace();
    }
});


